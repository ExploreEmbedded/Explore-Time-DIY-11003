
Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001530  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000012c  00800060  00001530  000015c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  0080018c  0080018c  000016f0  2**0
                  ALLOC
  3 .stab         00000e88  00000000  00000000  000016f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000214  00000000  00000000  00002578  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00002790  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001db3  00000000  00000000  000028d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007cc  00000000  00000000  00004683  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f0a  00000000  00000000  00004e4f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000057c  00000000  00000000  00005d5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000070f  00000000  00000000  000062d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001a42  00000000  00000000  000069e7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	70 c0       	rjmp	.+224    	; 0xe2 <__ctors_end>
       2:	8a c0       	rjmp	.+276    	; 0x118 <__bad_interrupt>
       4:	89 c0       	rjmp	.+274    	; 0x118 <__bad_interrupt>
       6:	88 c0       	rjmp	.+272    	; 0x118 <__bad_interrupt>
       8:	87 c0       	rjmp	.+270    	; 0x118 <__bad_interrupt>
       a:	86 c0       	rjmp	.+268    	; 0x118 <__bad_interrupt>
       c:	85 c0       	rjmp	.+266    	; 0x118 <__bad_interrupt>
       e:	84 c0       	rjmp	.+264    	; 0x118 <__bad_interrupt>
      10:	83 c0       	rjmp	.+262    	; 0x118 <__bad_interrupt>
      12:	82 c0       	rjmp	.+260    	; 0x118 <__bad_interrupt>
      14:	81 c0       	rjmp	.+258    	; 0x118 <__bad_interrupt>
      16:	80 c0       	rjmp	.+256    	; 0x118 <__bad_interrupt>
      18:	7f c0       	rjmp	.+254    	; 0x118 <__bad_interrupt>
      1a:	7e c0       	rjmp	.+252    	; 0x118 <__bad_interrupt>
      1c:	7d c0       	rjmp	.+250    	; 0x118 <__bad_interrupt>
      1e:	7c c0       	rjmp	.+248    	; 0x118 <__bad_interrupt>
      20:	7b c0       	rjmp	.+246    	; 0x118 <__bad_interrupt>
      22:	7a c0       	rjmp	.+244    	; 0x118 <__bad_interrupt>
      24:	79 c0       	rjmp	.+242    	; 0x118 <__bad_interrupt>
      26:	a0 c0       	rjmp	.+320    	; 0x168 <LCD_DisplayBigNum+0x16>
      28:	b7 c0       	rjmp	.+366    	; 0x198 <LCD_DisplayBigNum+0x46>
      2a:	ce c0       	rjmp	.+412    	; 0x1c8 <LCD_DisplayBigNum+0x76>
      2c:	e5 c0       	rjmp	.+458    	; 0x1f8 <LCD_DisplayBigNum+0xa6>
      2e:	fc c0       	rjmp	.+504    	; 0x228 <LCD_DisplayBigNum+0xd6>
      30:	13 c1       	rjmp	.+550    	; 0x258 <LCD_DisplayBigNum+0x106>
      32:	2a c1       	rjmp	.+596    	; 0x288 <LCD_DisplayBigNum+0x136>
      34:	41 c1       	rjmp	.+642    	; 0x2b8 <LCD_DisplayBigNum+0x166>
      36:	58 c1       	rjmp	.+688    	; 0x2e8 <LCD_DisplayBigNum+0x196>
      38:	6f c1       	rjmp	.+734    	; 0x318 <LCD_DisplayBigNum+0x1c6>
      3a:	19 c9       	rjmp	.-3534   	; 0xfffff26e <__eeprom_end+0xff7ef26e>
      3c:	1d c9       	rjmp	.-3526   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      3e:	1c c9       	rjmp	.-3528   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      40:	1b c9       	rjmp	.-3530   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      42:	1a c9       	rjmp	.-3532   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      44:	19 c9       	rjmp	.-3534   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      46:	18 c9       	rjmp	.-3536   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      48:	17 c9       	rjmp	.-3538   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      4a:	16 c9       	rjmp	.-3540   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      4c:	15 c9       	rjmp	.-3542   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      4e:	14 c9       	rjmp	.-3544   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      50:	13 c9       	rjmp	.-3546   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      52:	12 c9       	rjmp	.-3548   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      54:	11 c9       	rjmp	.-3550   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      56:	10 c9       	rjmp	.-3552   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      58:	0f c9       	rjmp	.-3554   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      5a:	0e c9       	rjmp	.-3556   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      5c:	0d c9       	rjmp	.-3558   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      5e:	0c c9       	rjmp	.-3560   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      60:	0b c9       	rjmp	.-3562   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      62:	0a c9       	rjmp	.-3564   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      64:	09 c9       	rjmp	.-3566   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      66:	08 c9       	rjmp	.-3568   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      68:	07 c9       	rjmp	.-3570   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      6a:	06 c9       	rjmp	.-3572   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      6c:	05 c9       	rjmp	.-3574   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      6e:	04 c9       	rjmp	.-3576   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      70:	03 c9       	rjmp	.-3578   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      72:	02 c9       	rjmp	.-3580   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      74:	db c8       	rjmp	.-3658   	; 0xfffff22c <__eeprom_end+0xff7ef22c>
      76:	49 c8       	rjmp	.-3950   	; 0xfffff10a <__eeprom_end+0xff7ef10a>
      78:	6a c8       	rjmp	.-3884   	; 0xfffff14e <__eeprom_end+0xff7ef14e>
      7a:	fe c8       	rjmp	.-3588   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      7c:	ea c8       	rjmp	.-3628   	; 0xfffff252 <__eeprom_end+0xff7ef252>
      7e:	fc c8       	rjmp	.-3592   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      80:	fb c8       	rjmp	.-3594   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      82:	fa c8       	rjmp	.-3596   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      84:	f9 c8       	rjmp	.-3598   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      86:	f8 c8       	rjmp	.-3600   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      88:	f7 c8       	rjmp	.-3602   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      8a:	f6 c8       	rjmp	.-3604   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      8c:	f5 c8       	rjmp	.-3606   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      8e:	f4 c8       	rjmp	.-3608   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      90:	f3 c8       	rjmp	.-3610   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      92:	f2 c8       	rjmp	.-3612   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      94:	f1 c8       	rjmp	.-3614   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      96:	e2 c8       	rjmp	.-3644   	; 0xfffff25c <__eeprom_end+0xff7ef25c>
      98:	ef c8       	rjmp	.-3618   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      9a:	87 c8       	rjmp	.-3826   	; 0xfffff1aa <__eeprom_end+0xff7ef1aa>
      9c:	ed c8       	rjmp	.-3622   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      9e:	ec c8       	rjmp	.-3624   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      a0:	a3 c8       	rjmp	.-3770   	; 0xfffff1e8 <__eeprom_end+0xff7ef1e8>
      a2:	ea c8       	rjmp	.-3628   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      a4:	e9 c8       	rjmp	.-3630   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      a6:	e8 c8       	rjmp	.-3632   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      a8:	e7 c8       	rjmp	.-3634   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      aa:	e6 c8       	rjmp	.-3636   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      ac:	e5 c8       	rjmp	.-3638   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      ae:	e4 c8       	rjmp	.-3640   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      b0:	e3 c8       	rjmp	.-3642   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      b2:	e2 c8       	rjmp	.-3644   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      b4:	a8 c8       	rjmp	.-3760   	; 0xfffff206 <__eeprom_end+0xff7ef206>
      b6:	29 c8       	rjmp	.-4014   	; 0xfffff10a <__eeprom_end+0xff7ef10a>
      b8:	30 c8       	rjmp	.-4000   	; 0xfffff11a <__eeprom_end+0xff7ef11a>
      ba:	de c8       	rjmp	.-3652   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      bc:	ca c8       	rjmp	.-3692   	; 0xfffff252 <__eeprom_end+0xff7ef252>
      be:	dc c8       	rjmp	.-3656   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      c0:	db c8       	rjmp	.-3658   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      c2:	da c8       	rjmp	.-3660   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      c4:	d9 c8       	rjmp	.-3662   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      c6:	d8 c8       	rjmp	.-3664   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      c8:	d7 c8       	rjmp	.-3666   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      ca:	d6 c8       	rjmp	.-3668   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      cc:	d5 c8       	rjmp	.-3670   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      ce:	d4 c8       	rjmp	.-3672   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      d0:	d3 c8       	rjmp	.-3674   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      d2:	d2 c8       	rjmp	.-3676   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      d4:	d1 c8       	rjmp	.-3678   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      d6:	c2 c8       	rjmp	.-3708   	; 0xfffff25c <__eeprom_end+0xff7ef25c>
      d8:	cf c8       	rjmp	.-3682   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      da:	57 c8       	rjmp	.-3922   	; 0xfffff18a <__eeprom_end+0xff7ef18a>
      dc:	cd c8       	rjmp	.-3686   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      de:	cc c8       	rjmp	.-3688   	; 0xfffff278 <__eeprom_end+0xff7ef278>
      e0:	73 c8       	rjmp	.-3866   	; 0xfffff1c8 <__eeprom_end+0xff7ef1c8>

000000e2 <__ctors_end>:
      e2:	11 24       	eor	r1, r1
      e4:	1f be       	out	0x3f, r1	; 63
      e6:	cf e5       	ldi	r28, 0x5F	; 95
      e8:	d4 e0       	ldi	r29, 0x04	; 4
      ea:	de bf       	out	0x3e, r29	; 62
      ec:	cd bf       	out	0x3d, r28	; 61

000000ee <__do_copy_data>:
      ee:	11 e0       	ldi	r17, 0x01	; 1
      f0:	a0 e6       	ldi	r26, 0x60	; 96
      f2:	b0 e0       	ldi	r27, 0x00	; 0
      f4:	e0 e3       	ldi	r30, 0x30	; 48
      f6:	f5 e1       	ldi	r31, 0x15	; 21
      f8:	02 c0       	rjmp	.+4      	; 0xfe <__do_copy_data+0x10>
      fa:	05 90       	lpm	r0, Z+
      fc:	0d 92       	st	X+, r0
      fe:	ac 38       	cpi	r26, 0x8C	; 140
     100:	b1 07       	cpc	r27, r17
     102:	d9 f7       	brne	.-10     	; 0xfa <__do_copy_data+0xc>

00000104 <__do_clear_bss>:
     104:	11 e0       	ldi	r17, 0x01	; 1
     106:	ac e8       	ldi	r26, 0x8C	; 140
     108:	b1 e0       	ldi	r27, 0x01	; 1
     10a:	01 c0       	rjmp	.+2      	; 0x10e <.do_clear_bss_start>

0000010c <.do_clear_bss_loop>:
     10c:	1d 92       	st	X+, r1

0000010e <.do_clear_bss_start>:
     10e:	a4 39       	cpi	r26, 0x94	; 148
     110:	b1 07       	cpc	r27, r17
     112:	e1 f7       	brne	.-8      	; 0x10c <.do_clear_bss_loop>
     114:	79 d4       	rcall	.+2290   	; 0xa08 <main>
     116:	0a ca       	rjmp	.-3052   	; 0xfffff52c <__eeprom_end+0xff7ef52c>

00000118 <__bad_interrupt>:
     118:	73 cf       	rjmp	.-282    	; 0x0 <__vectors>

0000011a <LCD_CreateCC>:

}

//Stores the segment pattern in LCD RAM
void LCD_CreateCC(uint8_t *pattern, uint8_t pos)
{
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
     11e:	ec 01       	movw	r28, r24
	 LCD_CmdWrite(0x40+(pos*8));
     120:	86 2f       	mov	r24, r22
     122:	88 0f       	add	r24, r24
     124:	88 0f       	add	r24, r24
     126:	88 0f       	add	r24, r24
     128:	80 5c       	subi	r24, 0xC0	; 192
     12a:	62 d5       	rcall	.+2756   	; 0xbf0 <LCD_CmdWrite>
		for(cnt=0; cnt<8; cnt++)
     12c:	10 92 8e 01 	sts	0x018E, r1
     130:	80 e0       	ldi	r24, 0x00	; 0
		{
			lcd_DataWrite(*(pattern+cnt));
     132:	fe 01       	movw	r30, r28
     134:	e8 0f       	add	r30, r24
     136:	f1 1d       	adc	r31, r1
     138:	80 81       	ld	r24, Z
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	00 d6       	rcall	.+3072   	; 0xd3e <lcd_DataWrite>

//Stores the segment pattern in LCD RAM
void LCD_CreateCC(uint8_t *pattern, uint8_t pos)
{
	 LCD_CmdWrite(0x40+(pos*8));
		for(cnt=0; cnt<8; cnt++)
     13e:	80 91 8e 01 	lds	r24, 0x018E
     142:	8f 5f       	subi	r24, 0xFF	; 255
     144:	80 93 8e 01 	sts	0x018E, r24
     148:	88 30       	cpi	r24, 0x08	; 8
     14a:	98 f3       	brcs	.-26     	; 0x132 <LCD_CreateCC+0x18>
		{
			lcd_DataWrite(*(pattern+cnt));
		}
}
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <LCD_DisplayBigNum>:

void LCD_DisplayBigNum(uint8_t num, uint8_t pos)
{
     152:	cf 93       	push	r28
     154:	c6 2f       	mov	r28, r22
	switch(num)
     156:	e8 2f       	mov	r30, r24
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	ea 30       	cpi	r30, 0x0A	; 10
     15c:	f1 05       	cpc	r31, r1
     15e:	08 f0       	brcs	.+2      	; 0x162 <LCD_DisplayBigNum+0x10>
     160:	f2 c0       	rjmp	.+484    	; 0x346 <LCD_DisplayBigNum+0x1f4>
     162:	ed 5e       	subi	r30, 0xED	; 237
     164:	ff 4f       	sbci	r31, 0xFF	; 255
     166:	09 94       	ijmp
	{	
		case 0:
		LCD_SetCursor(1,pos);
     168:	81 e0       	ldi	r24, 0x01	; 1
     16a:	58 d5       	rcall	.+2736   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(0);
     16c:	80 e0       	ldi	r24, 0x00	; 0
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	e6 d5       	rcall	.+3020   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(1);
     172:	81 e0       	ldi	r24, 0x01	; 1
     174:	90 e0       	ldi	r25, 0x00	; 0
     176:	e3 d5       	rcall	.+3014   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);;
     178:	82 e0       	ldi	r24, 0x02	; 2
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	e0 d5       	rcall	.+3008   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     17e:	82 e0       	ldi	r24, 0x02	; 2
     180:	6c 2f       	mov	r22, r28
     182:	4c d5       	rcall	.+2712   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(3);
     184:	83 e0       	ldi	r24, 0x03	; 3
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	da d5       	rcall	.+2996   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(4);
     18a:	84 e0       	ldi	r24, 0x04	; 4
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	d7 d5       	rcall	.+2990   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(5);
     190:	85 e0       	ldi	r24, 0x05	; 5
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	d4 d5       	rcall	.+2984   	; 0xd3e <lcd_DataWrite>
		break;
     196:	d7 c0       	rjmp	.+430    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 1:
		LCD_SetCursor(1,pos);
     198:	81 e0       	ldi	r24, 0x01	; 1
     19a:	40 d5       	rcall	.+2688   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(1);
     19c:	81 e0       	ldi	r24, 0x01	; 1
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	ce d5       	rcall	.+2972   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);
     1a2:	82 e0       	ldi	r24, 0x02	; 2
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	cb d5       	rcall	.+2966   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(' ');
     1a8:	80 e2       	ldi	r24, 0x20	; 32
     1aa:	90 e0       	ldi	r25, 0x00	; 0
     1ac:	c8 d5       	rcall	.+2960   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     1ae:	82 e0       	ldi	r24, 0x02	; 2
     1b0:	6c 2f       	mov	r22, r28
     1b2:	34 d5       	rcall	.+2664   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(' ');
     1b4:	80 e2       	ldi	r24, 0x20	; 32
     1b6:	90 e0       	ldi	r25, 0x00	; 0
     1b8:	c2 d5       	rcall	.+2948   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(255);
     1ba:	8f ef       	ldi	r24, 0xFF	; 255
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	bf d5       	rcall	.+2942   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(' ');
     1c0:	80 e2       	ldi	r24, 0x20	; 32
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	bc d5       	rcall	.+2936   	; 0xd3e <lcd_DataWrite>
		break;
     1c6:	bf c0       	rjmp	.+382    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 2:
		LCD_SetCursor(1,pos);
     1c8:	81 e0       	ldi	r24, 0x01	; 1
     1ca:	28 d5       	rcall	.+2640   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(6);
     1cc:	86 e0       	ldi	r24, 0x06	; 6
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	b6 d5       	rcall	.+2924   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);
     1d2:	86 e0       	ldi	r24, 0x06	; 6
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	b3 d5       	rcall	.+2918   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);;
     1d8:	82 e0       	ldi	r24, 0x02	; 2
     1da:	90 e0       	ldi	r25, 0x00	; 0
     1dc:	b0 d5       	rcall	.+2912   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     1de:	82 e0       	ldi	r24, 0x02	; 2
     1e0:	6c 2f       	mov	r22, r28
     1e2:	1c d5       	rcall	.+2616   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(3);
     1e4:	83 e0       	ldi	r24, 0x03	; 3
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	aa d5       	rcall	.+2900   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(7);
     1ea:	87 e0       	ldi	r24, 0x07	; 7
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	a7 d5       	rcall	.+2894   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(7);
     1f0:	87 e0       	ldi	r24, 0x07	; 7
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	a4 d5       	rcall	.+2888   	; 0xd3e <lcd_DataWrite>
		break;
     1f6:	a7 c0       	rjmp	.+334    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 3:
		LCD_SetCursor(1,pos);
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	10 d5       	rcall	.+2592   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(6);
     1fc:	86 e0       	ldi	r24, 0x06	; 6
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	9e d5       	rcall	.+2876   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);
     202:	86 e0       	ldi	r24, 0x06	; 6
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	9b d5       	rcall	.+2870   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);;
     208:	82 e0       	ldi	r24, 0x02	; 2
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	98 d5       	rcall	.+2864   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     20e:	82 e0       	ldi	r24, 0x02	; 2
     210:	6c 2f       	mov	r22, r28
     212:	04 d5       	rcall	.+2568   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(7);
     214:	87 e0       	ldi	r24, 0x07	; 7
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	92 d5       	rcall	.+2852   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(7);
     21a:	87 e0       	ldi	r24, 0x07	; 7
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	8f d5       	rcall	.+2846   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(5);
     220:	85 e0       	ldi	r24, 0x05	; 5
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	8c d5       	rcall	.+2840   	; 0xd3e <lcd_DataWrite>
		break;
     226:	8f c0       	rjmp	.+286    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 4:
		LCD_SetCursor(1,pos);
     228:	81 e0       	ldi	r24, 0x01	; 1
     22a:	f8 d4       	rcall	.+2544   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(3);
     22c:	83 e0       	ldi	r24, 0x03	; 3
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	86 d5       	rcall	.+2828   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(4);
     232:	84 e0       	ldi	r24, 0x04	; 4
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	83 d5       	rcall	.+2822   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);;
     238:	82 e0       	ldi	r24, 0x02	; 2
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	80 d5       	rcall	.+2816   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     23e:	82 e0       	ldi	r24, 0x02	; 2
     240:	6c 2f       	mov	r22, r28
     242:	ec d4       	rcall	.+2520   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(' ');
     244:	80 e2       	ldi	r24, 0x20	; 32
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	7a d5       	rcall	.+2804   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(' ');
     24a:	80 e2       	ldi	r24, 0x20	; 32
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	77 d5       	rcall	.+2798   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(255);
     250:	8f ef       	ldi	r24, 0xFF	; 255
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	74 d5       	rcall	.+2792   	; 0xd3e <lcd_DataWrite>
		break;
     256:	77 c0       	rjmp	.+238    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 5:
		LCD_SetCursor(1,pos);
     258:	81 e0       	ldi	r24, 0x01	; 1
     25a:	e0 d4       	rcall	.+2496   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(255);
     25c:	8f ef       	ldi	r24, 0xFF	; 255
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	6e d5       	rcall	.+2780   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);
     262:	86 e0       	ldi	r24, 0x06	; 6
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	6b d5       	rcall	.+2774   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);;
     268:	86 e0       	ldi	r24, 0x06	; 6
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	68 d5       	rcall	.+2768   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     26e:	82 e0       	ldi	r24, 0x02	; 2
     270:	6c 2f       	mov	r22, r28
     272:	d4 d4       	rcall	.+2472   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(7);
     274:	87 e0       	ldi	r24, 0x07	; 7
     276:	90 e0       	ldi	r25, 0x00	; 0
     278:	62 d5       	rcall	.+2756   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(7);
     27a:	87 e0       	ldi	r24, 0x07	; 7
     27c:	90 e0       	ldi	r25, 0x00	; 0
     27e:	5f d5       	rcall	.+2750   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(5);
     280:	85 e0       	ldi	r24, 0x05	; 5
     282:	90 e0       	ldi	r25, 0x00	; 0
     284:	5c d5       	rcall	.+2744   	; 0xd3e <lcd_DataWrite>
		break;
     286:	5f c0       	rjmp	.+190    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 6:
		LCD_SetCursor(1,pos);
     288:	81 e0       	ldi	r24, 0x01	; 1
     28a:	c8 d4       	rcall	.+2448   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(8);
     28c:	88 e0       	ldi	r24, 0x08	; 8
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	56 d5       	rcall	.+2732   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);
     292:	86 e0       	ldi	r24, 0x06	; 6
     294:	90 e0       	ldi	r25, 0x00	; 0
     296:	53 d5       	rcall	.+2726   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(6);;
     298:	86 e0       	ldi	r24, 0x06	; 6
     29a:	90 e0       	ldi	r25, 0x00	; 0
     29c:	50 d5       	rcall	.+2720   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     29e:	82 e0       	ldi	r24, 0x02	; 2
     2a0:	6c 2f       	mov	r22, r28
     2a2:	bc d4       	rcall	.+2424   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(3);
     2a4:	83 e0       	ldi	r24, 0x03	; 3
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	4a d5       	rcall	.+2708   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(7);
     2aa:	87 e0       	ldi	r24, 0x07	; 7
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	47 d5       	rcall	.+2702   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(5);
     2b0:	85 e0       	ldi	r24, 0x05	; 5
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	44 d5       	rcall	.+2696   	; 0xd3e <lcd_DataWrite>
		break;
     2b6:	47 c0       	rjmp	.+142    	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 7:
		LCD_SetCursor(1,pos);
     2b8:	81 e0       	ldi	r24, 0x01	; 1
     2ba:	b0 d4       	rcall	.+2400   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(1);
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	3e d5       	rcall	.+2684   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(1);
     2c2:	81 e0       	ldi	r24, 0x01	; 1
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	3b d5       	rcall	.+2678   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(2);;
     2c8:	82 e0       	ldi	r24, 0x02	; 2
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	38 d5       	rcall	.+2672   	; 0xd3e <lcd_DataWrite>
		LCD_SetCursor(2,pos);
     2ce:	82 e0       	ldi	r24, 0x02	; 2
     2d0:	6c 2f       	mov	r22, r28
     2d2:	a4 d4       	rcall	.+2376   	; 0xc1c <LCD_SetCursor>
		lcd_DataWrite(' ');
     2d4:	80 e2       	ldi	r24, 0x20	; 32
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	32 d5       	rcall	.+2660   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(8);
     2da:	88 e0       	ldi	r24, 0x08	; 8
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	2f d5       	rcall	.+2654   	; 0xd3e <lcd_DataWrite>
		lcd_DataWrite(' ');
     2e0:	80 e2       	ldi	r24, 0x20	; 32
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	2c d5       	rcall	.+2648   	; 0xd3e <lcd_DataWrite>
		break;
     2e6:	2f c0       	rjmp	.+94     	; 0x346 <LCD_DisplayBigNum+0x1f4>
		
		case 8:
		  LCD_SetCursor(1,pos); 
     2e8:	81 e0       	ldi	r24, 0x01	; 1
     2ea:	98 d4       	rcall	.+2352   	; 0xc1c <LCD_SetCursor>
		  lcd_DataWrite(0);  
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	26 d5       	rcall	.+2636   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(6); 
     2f2:	86 e0       	ldi	r24, 0x06	; 6
     2f4:	90 e0       	ldi	r25, 0x00	; 0
     2f6:	23 d5       	rcall	.+2630   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(2);;
     2f8:	82 e0       	ldi	r24, 0x02	; 2
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	20 d5       	rcall	.+2624   	; 0xd3e <lcd_DataWrite>
		  LCD_SetCursor(2,pos);
     2fe:	82 e0       	ldi	r24, 0x02	; 2
     300:	6c 2f       	mov	r22, r28
     302:	8c d4       	rcall	.+2328   	; 0xc1c <LCD_SetCursor>
		  lcd_DataWrite(3);  
     304:	83 e0       	ldi	r24, 0x03	; 3
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	1a d5       	rcall	.+2612   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(7);  
     30a:	87 e0       	ldi	r24, 0x07	; 7
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	17 d5       	rcall	.+2606   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(5);
     310:	85 e0       	ldi	r24, 0x05	; 5
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	14 d5       	rcall	.+2600   	; 0xd3e <lcd_DataWrite>
		  break; 	  
     316:	17 c0       	rjmp	.+46     	; 0x346 <LCD_DisplayBigNum+0x1f4>
		  case 9:
		  LCD_SetCursor(1,pos);
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	80 d4       	rcall	.+2304   	; 0xc1c <LCD_SetCursor>
		  lcd_DataWrite(8);
     31c:	88 e0       	ldi	r24, 0x08	; 8
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	0e d5       	rcall	.+2588   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(6);
     322:	86 e0       	ldi	r24, 0x06	; 6
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	0b d5       	rcall	.+2582   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(2);
     328:	82 e0       	ldi	r24, 0x02	; 2
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	08 d5       	rcall	.+2576   	; 0xd3e <lcd_DataWrite>
		  LCD_SetCursor(2,pos);
     32e:	82 e0       	ldi	r24, 0x02	; 2
     330:	6c 2f       	mov	r22, r28
     332:	74 d4       	rcall	.+2280   	; 0xc1c <LCD_SetCursor>
		  lcd_DataWrite(' ');
     334:	80 e2       	ldi	r24, 0x20	; 32
     336:	90 e0       	ldi	r25, 0x00	; 0
     338:	02 d5       	rcall	.+2564   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(' ');
     33a:	80 e2       	ldi	r24, 0x20	; 32
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	ff d4       	rcall	.+2558   	; 0xd3e <lcd_DataWrite>
		  lcd_DataWrite(255);	
     340:	8f ef       	ldi	r24, 0xFF	; 255
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	fc d4       	rcall	.+2552   	; 0xd3e <lcd_DataWrite>
		  break;
		default:break; 		
	}	
}
     346:	cf 91       	pop	r28
     348:	08 95       	ret

0000034a <LCD_DisplayTime>:

void LCD_DisplayTime(unsigned char hr,unsigned char min, unsigned char sec)
{
     34a:	1f 93       	push	r17
     34c:	cf 93       	push	r28
     34e:	df 93       	push	r29
     350:	18 2f       	mov	r17, r24
     352:	d6 2f       	mov	r29, r22
     354:	c4 2f       	mov	r28, r20
	float digit0=0, digit1=0;
	
	digit1 = hr/0x10;
     356:	68 2f       	mov	r22, r24
     358:	62 95       	swap	r22
     35a:	6f 70       	andi	r22, 0x0F	; 15
     35c:	70 e0       	ldi	r23, 0x00	; 0
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	52 d8       	rcall	.-3932   	; 0xfffff408 <__eeprom_end+0xff7ef408>
	digit0= hr%0x10;
	LCD_DisplayBigNum(digit1,0);  //display hour
     364:	23 d8       	rcall	.-4026   	; 0xfffff3ac <__eeprom_end+0xff7ef3ac>
     366:	86 2f       	mov	r24, r22
     368:	60 e0       	ldi	r22, 0x00	; 0
     36a:	f3 de       	rcall	.-538    	; 0x152 <LCD_DisplayBigNum>
void LCD_DisplayTime(unsigned char hr,unsigned char min, unsigned char sec)
{
	float digit0=0, digit1=0;
	
	digit1 = hr/0x10;
	digit0= hr%0x10;
     36c:	1f 70       	andi	r17, 0x0F	; 15
     36e:	61 2f       	mov	r22, r17
     370:	70 e0       	ldi	r23, 0x00	; 0
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	48 d8       	rcall	.-3952   	; 0xfffff408 <__eeprom_end+0xff7ef408>
	LCD_DisplayBigNum(digit1,0);  //display hour
	LCD_DisplayBigNum(digit0,3);
     378:	19 d8       	rcall	.-4046   	; 0xfffff3ac <__eeprom_end+0xff7ef3ac>
     37a:	86 2f       	mov	r24, r22
     37c:	63 e0       	ldi	r22, 0x03	; 3
     37e:	e9 de       	rcall	.-558    	; 0x152 <LCD_DisplayBigNum>
	
	// set colon
	LCD_SetCursor(1,6);
     380:	81 e0       	ldi	r24, 0x01	; 1
     382:	66 e0       	ldi	r22, 0x06	; 6
     384:	4b d4       	rcall	.+2198   	; 0xc1c <LCD_SetCursor>
	lcd_DataWrite(0xA5);
     386:	85 ea       	ldi	r24, 0xA5	; 165
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	d9 d4       	rcall	.+2482   	; 0xd3e <lcd_DataWrite>
	LCD_SetCursor(2,6);
     38c:	82 e0       	ldi	r24, 0x02	; 2
     38e:	66 e0       	ldi	r22, 0x06	; 6
     390:	45 d4       	rcall	.+2186   	; 0xc1c <LCD_SetCursor>
	lcd_DataWrite(0xA5);
     392:	85 ea       	ldi	r24, 0xA5	; 165
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	d3 d4       	rcall	.+2470   	; 0xd3e <lcd_DataWrite>
	  
	//display min  
	digit1 = min/0x10;
     398:	6d 2f       	mov	r22, r29
     39a:	62 95       	swap	r22
     39c:	6f 70       	andi	r22, 0x0F	; 15
     39e:	70 e0       	ldi	r23, 0x00	; 0
     3a0:	80 e0       	ldi	r24, 0x00	; 0
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	31 d8       	rcall	.-3998   	; 0xfffff408 <__eeprom_end+0xff7ef408>
     3a6:	dc 01       	movw	r26, r24
     3a8:	cb 01       	movw	r24, r22
	digit0= min%0x10;
	LCD_DisplayBigNum(digit1,7);  
     3aa:	bc 01       	movw	r22, r24
     3ac:	cd 01       	movw	r24, r26
     3ae:	fe d7       	rcall	.+4092   	; 0x13ac <__fixunssfsi>
     3b0:	86 2f       	mov	r24, r22
     3b2:	67 e0       	ldi	r22, 0x07	; 7
     3b4:	ce de       	rcall	.-612    	; 0x152 <LCD_DisplayBigNum>
	LCD_SetCursor(2,6);
	lcd_DataWrite(0xA5);
	  
	//display min  
	digit1 = min/0x10;
	digit0= min%0x10;
     3b6:	df 70       	andi	r29, 0x0F	; 15
     3b8:	6d 2f       	mov	r22, r29
     3ba:	70 e0       	ldi	r23, 0x00	; 0
     3bc:	80 e0       	ldi	r24, 0x00	; 0
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	23 d8       	rcall	.-4026   	; 0xfffff408 <__eeprom_end+0xff7ef408>
	LCD_DisplayBigNum(digit1,7);  
	LCD_DisplayBigNum(digit0,10);
     3c2:	f4 d7       	rcall	.+4072   	; 0x13ac <__fixunssfsi>
     3c4:	86 2f       	mov	r24, r22
     3c6:	6a e0       	ldi	r22, 0x0A	; 10
     3c8:	c4 de       	rcall	.-632    	; 0x152 <LCD_DisplayBigNum>
	
	//display sec
	// LCD_SetCursor(1,14);
	//LCD_DisplayString("pm");
	 LCD_SetCursor(2,14);
     3ca:	82 e0       	ldi	r24, 0x02	; 2
     3cc:	6e e0       	ldi	r22, 0x0E	; 14
     3ce:	26 d4       	rcall	.+2124   	; 0xc1c <LCD_SetCursor>
	 LCD_Printf("%2x",sec);	
     3d0:	00 d0       	rcall	.+0      	; 0x3d2 <LCD_DisplayTime+0x88>
     3d2:	00 d0       	rcall	.+0      	; 0x3d4 <LCD_DisplayTime+0x8a>
     3d4:	ed b7       	in	r30, 0x3d	; 61
     3d6:	fe b7       	in	r31, 0x3e	; 62
     3d8:	31 96       	adiw	r30, 0x01	; 1
     3da:	80 e6       	ldi	r24, 0x60	; 96
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	ad b7       	in	r26, 0x3d	; 61
     3e0:	be b7       	in	r27, 0x3e	; 62
     3e2:	12 96       	adiw	r26, 0x02	; 2
     3e4:	9c 93       	st	X, r25
     3e6:	8e 93       	st	-X, r24
     3e8:	11 97       	sbiw	r26, 0x01	; 1
     3ea:	c2 83       	std	Z+2, r28	; 0x02
     3ec:	13 82       	std	Z+3, r1	; 0x03
     3ee:	3d d6       	rcall	.+3194   	; 0x106a <LCD_Printf>
     3f0:	0f 90       	pop	r0
     3f2:	0f 90       	pop	r0
     3f4:	0f 90       	pop	r0
     3f6:	0f 90       	pop	r0
}
     3f8:	df 91       	pop	r29
     3fa:	cf 91       	pop	r28
     3fc:	1f 91       	pop	r17
     3fe:	08 95       	ret

00000400 <LCD_DisplayMenu>:


uint8_t LCD_DisplayMenu()
{ 
     400:	af 92       	push	r10
     402:	bf 92       	push	r11
     404:	cf 92       	push	r12
     406:	df 92       	push	r13
     408:	ef 92       	push	r14
     40a:	ff 92       	push	r15
     40c:	0f 93       	push	r16
     40e:	1f 93       	push	r17
     410:	cf 93       	push	r28
     412:	df 93       	push	r29
	int8_t keycount=0;
	LCD_Clear();
     414:	3d d4       	rcall	.+2170   	; 0xc90 <LCD_Clear>
	LCD_GoToLine(1);
     416:	81 e0       	ldi	r24, 0x01	; 1
     418:	2c d4       	rcall	.+2136   	; 0xc72 <LCD_GoToLine>
	LCD_DisplayString("    Settings    ");
     41a:	84 e6       	ldi	r24, 0x64	; 100
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	17 d6       	rcall	.+3118   	; 0x104e <LCD_DisplayString>
}


uint8_t LCD_DisplayMenu()
{ 
	int8_t keycount=0;
     420:	c0 e0       	ldi	r28, 0x00	; 0
				_delay_ms(100);
			}
		
			if((keycount>=menusize)||(keycount <= -menusize))
			{
				keycount=0;
     422:	d0 e0       	ldi	r29, 0x00	; 0
			{
				keycount += menusize;   //make menu index circular. i.e decrement from first option shows the last option on the menu
			}			
			
     		LCD_GoToLine(2);
			LCD_DisplayString("                "); //clear second line
     424:	0f 2e       	mov	r0, r31
     426:	f5 e7       	ldi	r31, 0x75	; 117
     428:	cf 2e       	mov	r12, r31
     42a:	f0 e0       	ldi	r31, 0x00	; 0
     42c:	df 2e       	mov	r13, r31
     42e:	f0 2d       	mov	r31, r0
			LCD_SetCursor(2,(14-strlen(settings[keycount]))/2); //set cursor at the center of of line 2 depending on string size. 
     430:	0f 2e       	mov	r0, r31
     432:	fe e0       	ldi	r31, 0x0E	; 14
     434:	ef 2e       	mov	r14, r31
     436:	ff 24       	eor	r15, r15
     438:	f0 2d       	mov	r31, r0
			LCD_Printf("<%s>", settings[keycount]);
     43a:	0f 2e       	mov	r0, r31
     43c:	f6 e8       	ldi	r31, 0x86	; 134
     43e:	af 2e       	mov	r10, r31
     440:	f0 e0       	ldi	r31, 0x00	; 0
     442:	bf 2e       	mov	r11, r31
     444:	f0 2d       	mov	r31, r0
	int8_t keycount=0;
	LCD_Clear();
	LCD_GoToLine(1);
	LCD_DisplayString("    Settings    ");
	do{       
			if(util_IsBitCleared(Button, up))
     446:	85 99       	sbic	0x10, 5	; 16
     448:	0a c0       	rjmp	.+20     	; 0x45e <LCD_DisplayMenu+0x5e>
			{
				keycount++;
     44a:	cf 5f       	subi	r28, 0xFF	; 255
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     44c:	8f ef       	ldi	r24, 0xFF	; 255
     44e:	90 e7       	ldi	r25, 0x70	; 112
     450:	a2 e0       	ldi	r26, 0x02	; 2
     452:	81 50       	subi	r24, 0x01	; 1
     454:	90 40       	sbci	r25, 0x00	; 0
     456:	a0 40       	sbci	r26, 0x00	; 0
     458:	e1 f7       	brne	.-8      	; 0x452 <LCD_DisplayMenu+0x52>
     45a:	00 c0       	rjmp	.+0      	; 0x45c <LCD_DisplayMenu+0x5c>
     45c:	00 00       	nop
				_delay_ms(100);
			}
			
			if(util_IsBitCleared(Button, down))
     45e:	84 99       	sbic	0x10, 4	; 16
     460:	0a c0       	rjmp	.+20     	; 0x476 <__stack+0x17>
			{
				keycount--;
     462:	c1 50       	subi	r28, 0x01	; 1
     464:	8f ef       	ldi	r24, 0xFF	; 255
     466:	90 e7       	ldi	r25, 0x70	; 112
     468:	a2 e0       	ldi	r26, 0x02	; 2
     46a:	81 50       	subi	r24, 0x01	; 1
     46c:	90 40       	sbci	r25, 0x00	; 0
     46e:	a0 40       	sbci	r26, 0x00	; 0
     470:	e1 f7       	brne	.-8      	; 0x46a <__stack+0xb>
     472:	00 c0       	rjmp	.+0      	; 0x474 <__stack+0x15>
     474:	00 00       	nop
				_delay_ms(100);
			}
		
			if((keycount>=menusize)||(keycount <= -menusize))
     476:	8c 2f       	mov	r24, r28
     478:	8c 5f       	subi	r24, 0xFC	; 252
     47a:	89 30       	cpi	r24, 0x09	; 9
     47c:	20 f4       	brcc	.+8      	; 0x486 <__stack+0x27>
			{
				keycount=0;
			}
			
			if(keycount<0)
     47e:	cc 23       	and	r28, r28
     480:	1c f4       	brge	.+6      	; 0x488 <__stack+0x29>
			{
				keycount += menusize;   //make menu index circular. i.e decrement from first option shows the last option on the menu
     482:	cb 5f       	subi	r28, 0xFB	; 251
     484:	01 c0       	rjmp	.+2      	; 0x488 <__stack+0x29>
				_delay_ms(100);
			}
		
			if((keycount>=menusize)||(keycount <= -menusize))
			{
				keycount=0;
     486:	cd 2f       	mov	r28, r29
			if(keycount<0)
			{
				keycount += menusize;   //make menu index circular. i.e decrement from first option shows the last option on the menu
			}			
			
     		LCD_GoToLine(2);
     488:	82 e0       	ldi	r24, 0x02	; 2
     48a:	f3 d3       	rcall	.+2022   	; 0xc72 <LCD_GoToLine>
			LCD_DisplayString("                "); //clear second line
     48c:	c6 01       	movw	r24, r12
     48e:	df d5       	rcall	.+3006   	; 0x104e <LCD_DisplayString>
			LCD_SetCursor(2,(14-strlen(settings[keycount]))/2); //set cursor at the center of of line 2 depending on string size. 
     490:	0c 2f       	mov	r16, r28
     492:	11 27       	eor	r17, r17
     494:	07 fd       	sbrc	r16, 7
     496:	10 95       	com	r17
     498:	02 95       	swap	r16
     49a:	12 95       	swap	r17
     49c:	10 7f       	andi	r17, 0xF0	; 240
     49e:	10 27       	eor	r17, r16
     4a0:	00 7f       	andi	r16, 0xF0	; 240
     4a2:	10 27       	eor	r17, r16
     4a4:	0a 50       	subi	r16, 0x0A	; 10
     4a6:	1f 4f       	sbci	r17, 0xFF	; 255
     4a8:	a0 2f       	mov	r26, r16
     4aa:	b1 2f       	mov	r27, r17
     4ac:	fd 01       	movw	r30, r26
     4ae:	01 90       	ld	r0, Z+
     4b0:	00 20       	and	r0, r0
     4b2:	e9 f7       	brne	.-6      	; 0x4ae <__stack+0x4f>
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	ea 1b       	sub	r30, r26
     4b8:	fb 0b       	sbc	r31, r27
     4ba:	b7 01       	movw	r22, r14
     4bc:	6e 1b       	sub	r22, r30
     4be:	7f 0b       	sbc	r23, r31
     4c0:	76 95       	lsr	r23
     4c2:	67 95       	ror	r22
     4c4:	82 e0       	ldi	r24, 0x02	; 2
     4c6:	aa d3       	rcall	.+1876   	; 0xc1c <LCD_SetCursor>
			LCD_Printf("<%s>", settings[keycount]);
     4c8:	00 d0       	rcall	.+0      	; 0x4ca <__stack+0x6b>
     4ca:	00 d0       	rcall	.+0      	; 0x4cc <__stack+0x6d>
     4cc:	ad b7       	in	r26, 0x3d	; 61
     4ce:	be b7       	in	r27, 0x3e	; 62
     4d0:	12 96       	adiw	r26, 0x02	; 2
     4d2:	bc 92       	st	X, r11
     4d4:	ae 92       	st	-X, r10
     4d6:	11 97       	sbiw	r26, 0x01	; 1
     4d8:	14 96       	adiw	r26, 0x04	; 4
     4da:	1c 93       	st	X, r17
     4dc:	0e 93       	st	-X, r16
     4de:	13 97       	sbiw	r26, 0x03	; 3
     4e0:	c4 d5       	rcall	.+2952   	; 0x106a <LCD_Printf>
     4e2:	8f ef       	ldi	r24, 0xFF	; 255
     4e4:	90 e7       	ldi	r25, 0x70	; 112
     4e6:	a2 e0       	ldi	r26, 0x02	; 2
     4e8:	81 50       	subi	r24, 0x01	; 1
     4ea:	90 40       	sbci	r25, 0x00	; 0
     4ec:	a0 40       	sbci	r26, 0x00	; 0
     4ee:	e1 f7       	brne	.-8      	; 0x4e8 <__stack+0x89>
     4f0:	00 c0       	rjmp	.+0      	; 0x4f2 <__stack+0x93>
     4f2:	00 00       	nop
		    _delay_ms(100);  //make menu visible or else will overwrite at fast speed
			    		 
      }while(util_IsBitSet(Button,select));
     4f4:	0f 90       	pop	r0
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	83 99       	sbic	0x10, 3	; 16
     4fe:	a3 cf       	rjmp	.-186    	; 0x446 <LCD_DisplayMenu+0x46>
	  while(util_IsBitCleared(Button,select)); //wait till button is released. 
     500:	83 9b       	sbis	0x10, 3	; 16
     502:	fe cf       	rjmp	.-4      	; 0x500 <__stack+0xa1>
	  return keycount;
}
     504:	8c 2f       	mov	r24, r28
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	df 90       	pop	r13
     514:	cf 90       	pop	r12
     516:	bf 90       	pop	r11
     518:	af 90       	pop	r10
     51a:	08 95       	ret

0000051c <setAlarm>:
}

void setAlarm()
{
 
  LCD_Clear();
     51c:	b9 d3       	rcall	.+1906   	; 0xc90 <LCD_Clear>
  LCD_DisplayString("Turn Alarm ON");
     51e:	8b e8       	ldi	r24, 0x8B	; 139
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	95 d5       	rcall	.+2858   	; 0x104e <LCD_DisplayString>
  do{
       util_BitSet(buzzer_port,buzzer_pin);
     524:	c3 9a       	sbi	0x18, 3	; 24
  }while(util_IsBitSet(Button, select));
     526:	83 99       	sbic	0x10, 3	; 16
     528:	fd cf       	rjmp	.-6      	; 0x524 <setAlarm+0x8>
  while(util_IsBitCleared(Button,select));
     52a:	83 9b       	sbis	0x10, 3	; 16
     52c:	fe cf       	rjmp	.-4      	; 0x52a <setAlarm+0xe>
  util_BitClear(buzzer_port,buzzer_pin);
     52e:	c3 98       	cbi	0x18, 3	; 24
   
}
     530:	08 95       	ret

00000532 <dec2bcd>:

// Convert Decimal to Binary Coded Decimal (BCD)
uint8_t dec2bcd(uint8_t num)
{
	return ((num/10 * 16) + (num % 10));
     532:	6a e0       	ldi	r22, 0x0A	; 10
     534:	cd d7       	rcall	.+3994   	; 0x14d0 <__udivmodqi4>
     536:	82 95       	swap	r24
     538:	80 7f       	andi	r24, 0xF0	; 240
}
     53a:	89 0f       	add	r24, r25
     53c:	08 95       	ret

0000053e <bcd2dec>:
// Convert Binary Coded Decimal (BCD) to Decimal
uint8_t bcd2dec(uint8_t num)
{
	return ((num/16 * 10) + (num % 16));
     53e:	98 2f       	mov	r25, r24
     540:	92 95       	swap	r25
     542:	9f 70       	andi	r25, 0x0F	; 15
     544:	99 0f       	add	r25, r25
     546:	29 2f       	mov	r18, r25
     548:	22 0f       	add	r18, r18
     54a:	22 0f       	add	r18, r18
     54c:	92 0f       	add	r25, r18
     54e:	8f 70       	andi	r24, 0x0F	; 15
     550:	89 0f       	add	r24, r25
     552:	08 95       	ret

00000554 <setDate>:
	   _delay_ms(2000);
	  
}

void setDate(uint8_t day, uint8_t month, uint8_t year)
{  
     554:	ef 92       	push	r14
     556:	ff 92       	push	r15
     558:	0f 93       	push	r16
     55a:	1f 93       	push	r17
     55c:	cf 93       	push	r28
     55e:	df 93       	push	r29
     560:	d6 2f       	mov	r29, r22
     562:	14 2f       	mov	r17, r20
	uint8_t d_day, d_month, d_year;
	uint8_t cnt=0;
	
	d_day = bcd2dec(day);
     564:	ec df       	rcall	.-40     	; 0x53e <bcd2dec>
     566:	c8 2f       	mov	r28, r24
	d_month = bcd2dec(month);
     568:	8d 2f       	mov	r24, r29
     56a:	e9 df       	rcall	.-46     	; 0x53e <bcd2dec>
     56c:	d8 2f       	mov	r29, r24
	d_year= bcd2dec(year);
     56e:	81 2f       	mov	r24, r17
     570:	e6 df       	rcall	.-52     	; 0x53e <bcd2dec>
     572:	18 2f       	mov	r17, r24
	LCD_Clear();
     574:	8d d3       	rcall	.+1818   	; 0xc90 <LCD_Clear>
	LCD_GoToLine(1);
     576:	81 e0       	ldi	r24, 0x01	; 1
     578:	7c d3       	rcall	.+1784   	; 0xc72 <LCD_GoToLine>
	LCD_Printf(" DD    MM   YY");
     57a:	00 d0       	rcall	.+0      	; 0x57c <setDate+0x28>
     57c:	89 e9       	ldi	r24, 0x99	; 153
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	ad b7       	in	r26, 0x3d	; 61
     582:	be b7       	in	r27, 0x3e	; 62
     584:	12 96       	adiw	r26, 0x02	; 2
     586:	9c 93       	st	X, r25
     588:	8e 93       	st	-X, r24
     58a:	11 97       	sbiw	r26, 0x01	; 1
     58c:	6e d5       	rcall	.+2780   	; 0x106a <LCD_Printf>
	LCD_GoToLine(2);
     58e:	0f 90       	pop	r0
     590:	0f 90       	pop	r0
     592:	82 e0       	ldi	r24, 0x02	; 2
     594:	6e d3       	rcall	.+1756   	; 0xc72 <LCD_GoToLine>
	LCD_Printf("<%2d>  <%2d> <%2d>" , d_day, d_month, d_year);
     596:	ed b7       	in	r30, 0x3d	; 61
     598:	fe b7       	in	r31, 0x3e	; 62
     59a:	38 97       	sbiw	r30, 0x08	; 8
     59c:	0f b6       	in	r0, 0x3f	; 63
     59e:	f8 94       	cli
     5a0:	fe bf       	out	0x3e, r31	; 62
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	ed bf       	out	0x3d, r30	; 61
     5a6:	31 96       	adiw	r30, 0x01	; 1
     5a8:	88 ea       	ldi	r24, 0xA8	; 168
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	ad b7       	in	r26, 0x3d	; 61
     5ae:	be b7       	in	r27, 0x3e	; 62
     5b0:	12 96       	adiw	r26, 0x02	; 2
     5b2:	9c 93       	st	X, r25
     5b4:	8e 93       	st	-X, r24
     5b6:	11 97       	sbiw	r26, 0x01	; 1
     5b8:	c2 83       	std	Z+2, r28	; 0x02
     5ba:	13 82       	std	Z+3, r1	; 0x03
     5bc:	d4 83       	std	Z+4, r29	; 0x04
     5be:	15 82       	std	Z+5, r1	; 0x05
     5c0:	16 83       	std	Z+6, r17	; 0x06
     5c2:	17 82       	std	Z+7, r1	; 0x07
     5c4:	52 d5       	rcall	.+2724   	; 0x106a <LCD_Printf>
     5c6:	ed b7       	in	r30, 0x3d	; 61
     5c8:	fe b7       	in	r31, 0x3e	; 62
     5ca:	38 96       	adiw	r30, 0x08	; 8
     5cc:	0f b6       	in	r0, 0x3f	; 63
     5ce:	f8 94       	cli
     5d0:	fe bf       	out	0x3e, r31	; 62
     5d2:	0f be       	out	0x3f, r0	; 63
     5d4:	ed bf       	out	0x3d, r30	; 61
					_delay_ms(200);
				}
				
				if(d_day>31)
				{
					d_day=0;
     5d6:	00 e0       	ldi	r16, 0x00	; 0
				}
				
				LCD_Printf("%2d",d_day);
     5d8:	0f 2e       	mov	r0, r31
     5da:	fb eb       	ldi	r31, 0xBB	; 187
     5dc:	ef 2e       	mov	r14, r31
     5de:	f0 e0       	ldi	r31, 0x00	; 0
     5e0:	ff 2e       	mov	r15, r31
     5e2:	f0 2d       	mov	r31, r0
	LCD_GoToLine(2);
	LCD_Printf("<%2d>  <%2d> <%2d>" , d_day, d_month, d_year);

			
		do {	
			    LCD_SetCursor(2,1);
     5e4:	82 e0       	ldi	r24, 0x02	; 2
     5e6:	61 e0       	ldi	r22, 0x01	; 1
     5e8:	19 d3       	rcall	.+1586   	; 0xc1c <LCD_SetCursor>
     5ea:	8f ef       	ldi	r24, 0xFF	; 255
     5ec:	90 e7       	ldi	r25, 0x70	; 112
     5ee:	a2 e0       	ldi	r26, 0x02	; 2
     5f0:	81 50       	subi	r24, 0x01	; 1
     5f2:	90 40       	sbci	r25, 0x00	; 0
     5f4:	a0 40       	sbci	r26, 0x00	; 0
     5f6:	e1 f7       	brne	.-8      	; 0x5f0 <setDate+0x9c>
     5f8:	00 c0       	rjmp	.+0      	; 0x5fa <setDate+0xa6>
     5fa:	00 00       	nop
				_delay_ms(100);
				if(util_IsBitCleared(Button, up))
     5fc:	85 99       	sbic	0x10, 5	; 16
     5fe:	0a c0       	rjmp	.+20     	; 0x614 <setDate+0xc0>
				{
					d_day++;
     600:	cf 5f       	subi	r28, 0xFF	; 255
     602:	8f ef       	ldi	r24, 0xFF	; 255
     604:	91 ee       	ldi	r25, 0xE1	; 225
     606:	a4 e0       	ldi	r26, 0x04	; 4
     608:	81 50       	subi	r24, 0x01	; 1
     60a:	90 40       	sbci	r25, 0x00	; 0
     60c:	a0 40       	sbci	r26, 0x00	; 0
     60e:	e1 f7       	brne	.-8      	; 0x608 <setDate+0xb4>
     610:	00 c0       	rjmp	.+0      	; 0x612 <setDate+0xbe>
     612:	00 00       	nop
					_delay_ms(200);
				}
				if(util_IsBitCleared(Button, down))
     614:	84 99       	sbic	0x10, 4	; 16
     616:	0a c0       	rjmp	.+20     	; 0x62c <setDate+0xd8>
				{
					d_day--;
     618:	c1 50       	subi	r28, 0x01	; 1
     61a:	8f ef       	ldi	r24, 0xFF	; 255
     61c:	91 ee       	ldi	r25, 0xE1	; 225
     61e:	a4 e0       	ldi	r26, 0x04	; 4
     620:	81 50       	subi	r24, 0x01	; 1
     622:	90 40       	sbci	r25, 0x00	; 0
     624:	a0 40       	sbci	r26, 0x00	; 0
     626:	e1 f7       	brne	.-8      	; 0x620 <setDate+0xcc>
     628:	00 c0       	rjmp	.+0      	; 0x62a <setDate+0xd6>
     62a:	00 00       	nop
					_delay_ms(200);
				}
				
				if(d_day>31)
     62c:	c0 32       	cpi	r28, 0x20	; 32
     62e:	08 f0       	brcs	.+2      	; 0x632 <setDate+0xde>
				{
					d_day=0;
     630:	c0 2f       	mov	r28, r16
				}
				
				LCD_Printf("%2d",d_day);
     632:	00 d0       	rcall	.+0      	; 0x634 <setDate+0xe0>
     634:	00 d0       	rcall	.+0      	; 0x636 <setDate+0xe2>
     636:	ed b7       	in	r30, 0x3d	; 61
     638:	fe b7       	in	r31, 0x3e	; 62
     63a:	31 96       	adiw	r30, 0x01	; 1
     63c:	ad b7       	in	r26, 0x3d	; 61
     63e:	be b7       	in	r27, 0x3e	; 62
     640:	12 96       	adiw	r26, 0x02	; 2
     642:	fc 92       	st	X, r15
     644:	ee 92       	st	-X, r14
     646:	11 97       	sbiw	r26, 0x01	; 1
     648:	c2 83       	std	Z+2, r28	; 0x02
     64a:	13 82       	std	Z+3, r1	; 0x03
     64c:	0e d5       	rcall	.+2588   	; 0x106a <LCD_Printf>
				
		  } while (util_IsBitSet(Button, select));
     64e:	0f 90       	pop	r0
     650:	0f 90       	pop	r0
     652:	0f 90       	pop	r0
     654:	0f 90       	pop	r0
     656:	83 99       	sbic	0x10, 3	; 16
     658:	c5 cf       	rjmp	.-118    	; 0x5e4 <setDate+0x90>
		  while(util_IsBitCleared(Button,select));
     65a:	83 9b       	sbis	0x10, 3	; 16
     65c:	fe cf       	rjmp	.-4      	; 0x65a <setDate+0x106>
				_delay_ms(200);
			}
			  	
			if(d_month>12)
			{
				d_month=0;
     65e:	00 e0       	ldi	r16, 0x00	; 0
			}
			  	
			LCD_Printf("%2d",d_month);
     660:	0f 2e       	mov	r0, r31
     662:	fb eb       	ldi	r31, 0xBB	; 187
     664:	ef 2e       	mov	r14, r31
     666:	f0 e0       	ldi	r31, 0x00	; 0
     668:	ff 2e       	mov	r15, r31
     66a:	f0 2d       	mov	r31, r0
		  
		  
		//update month
		
		do {
			LCD_SetCursor(2,7);
     66c:	82 e0       	ldi	r24, 0x02	; 2
     66e:	67 e0       	ldi	r22, 0x07	; 7
     670:	d5 d2       	rcall	.+1450   	; 0xc1c <LCD_SetCursor>
     672:	8f ef       	ldi	r24, 0xFF	; 255
     674:	90 e7       	ldi	r25, 0x70	; 112
     676:	a2 e0       	ldi	r26, 0x02	; 2
     678:	81 50       	subi	r24, 0x01	; 1
     67a:	90 40       	sbci	r25, 0x00	; 0
     67c:	a0 40       	sbci	r26, 0x00	; 0
     67e:	e1 f7       	brne	.-8      	; 0x678 <setDate+0x124>
     680:	00 c0       	rjmp	.+0      	; 0x682 <setDate+0x12e>
     682:	00 00       	nop
			_delay_ms(100);
			if(util_IsBitCleared(Button, up))
     684:	85 99       	sbic	0x10, 5	; 16
     686:	0a c0       	rjmp	.+20     	; 0x69c <setDate+0x148>
			{
				d_month++;
     688:	df 5f       	subi	r29, 0xFF	; 255
     68a:	8f ef       	ldi	r24, 0xFF	; 255
     68c:	91 ee       	ldi	r25, 0xE1	; 225
     68e:	a4 e0       	ldi	r26, 0x04	; 4
     690:	81 50       	subi	r24, 0x01	; 1
     692:	90 40       	sbci	r25, 0x00	; 0
     694:	a0 40       	sbci	r26, 0x00	; 0
     696:	e1 f7       	brne	.-8      	; 0x690 <setDate+0x13c>
     698:	00 c0       	rjmp	.+0      	; 0x69a <setDate+0x146>
     69a:	00 00       	nop
				_delay_ms(200);
			}
			if(util_IsBitCleared(Button, down))
     69c:	84 99       	sbic	0x10, 4	; 16
     69e:	0a c0       	rjmp	.+20     	; 0x6b4 <setDate+0x160>
			{
				d_month--;
     6a0:	d1 50       	subi	r29, 0x01	; 1
     6a2:	8f ef       	ldi	r24, 0xFF	; 255
     6a4:	91 ee       	ldi	r25, 0xE1	; 225
     6a6:	a4 e0       	ldi	r26, 0x04	; 4
     6a8:	81 50       	subi	r24, 0x01	; 1
     6aa:	90 40       	sbci	r25, 0x00	; 0
     6ac:	a0 40       	sbci	r26, 0x00	; 0
     6ae:	e1 f7       	brne	.-8      	; 0x6a8 <setDate+0x154>
     6b0:	00 c0       	rjmp	.+0      	; 0x6b2 <setDate+0x15e>
     6b2:	00 00       	nop
				_delay_ms(200);
			}
			  	
			if(d_month>12)
     6b4:	dd 30       	cpi	r29, 0x0D	; 13
     6b6:	08 f0       	brcs	.+2      	; 0x6ba <setDate+0x166>
			{
				d_month=0;
     6b8:	d0 2f       	mov	r29, r16
			}
			  	
			LCD_Printf("%2d",d_month);
     6ba:	00 d0       	rcall	.+0      	; 0x6bc <setDate+0x168>
     6bc:	00 d0       	rcall	.+0      	; 0x6be <setDate+0x16a>
     6be:	ed b7       	in	r30, 0x3d	; 61
     6c0:	fe b7       	in	r31, 0x3e	; 62
     6c2:	31 96       	adiw	r30, 0x01	; 1
     6c4:	ad b7       	in	r26, 0x3d	; 61
     6c6:	be b7       	in	r27, 0x3e	; 62
     6c8:	12 96       	adiw	r26, 0x02	; 2
     6ca:	fc 92       	st	X, r15
     6cc:	ee 92       	st	-X, r14
     6ce:	11 97       	sbiw	r26, 0x01	; 1
     6d0:	d2 83       	std	Z+2, r29	; 0x02
     6d2:	13 82       	std	Z+3, r1	; 0x03
     6d4:	ca d4       	rcall	.+2452   	; 0x106a <LCD_Printf>
			  	
			  	
		} while (util_IsBitSet(Button, select));
     6d6:	0f 90       	pop	r0
     6d8:	0f 90       	pop	r0
     6da:	0f 90       	pop	r0
     6dc:	0f 90       	pop	r0
     6de:	83 99       	sbic	0x10, 3	; 16
     6e0:	c5 cf       	rjmp	.-118    	; 0x66c <setDate+0x118>
		while(util_IsBitCleared(Button,select));
     6e2:	83 9b       	sbis	0x10, 3	; 16
     6e4:	fe cf       	rjmp	.-4      	; 0x6e2 <setDate+0x18e>
				_delay_ms(200);
			}
				
			if(d_year>=99)
			{
				d_year=0;
     6e6:	00 e0       	ldi	r16, 0x00	; 0
			}
				
			LCD_Printf("%2d",d_year);
     6e8:	0f 2e       	mov	r0, r31
     6ea:	fb eb       	ldi	r31, 0xBB	; 187
     6ec:	ef 2e       	mov	r14, r31
     6ee:	f0 e0       	ldi	r31, 0x00	; 0
     6f0:	ff 2e       	mov	r15, r31
     6f2:	f0 2d       	mov	r31, r0
		while(util_IsBitCleared(Button,select));
		
		//set year
		
		do {
			LCD_SetCursor(2,12);
     6f4:	82 e0       	ldi	r24, 0x02	; 2
     6f6:	6c e0       	ldi	r22, 0x0C	; 12
     6f8:	91 d2       	rcall	.+1314   	; 0xc1c <LCD_SetCursor>
     6fa:	8f ef       	ldi	r24, 0xFF	; 255
     6fc:	90 e7       	ldi	r25, 0x70	; 112
     6fe:	a2 e0       	ldi	r26, 0x02	; 2
     700:	81 50       	subi	r24, 0x01	; 1
     702:	90 40       	sbci	r25, 0x00	; 0
     704:	a0 40       	sbci	r26, 0x00	; 0
     706:	e1 f7       	brne	.-8      	; 0x700 <setDate+0x1ac>
     708:	00 c0       	rjmp	.+0      	; 0x70a <setDate+0x1b6>
     70a:	00 00       	nop
			_delay_ms(100);
			if(util_IsBitCleared(Button, up))
     70c:	85 99       	sbic	0x10, 5	; 16
     70e:	0a c0       	rjmp	.+20     	; 0x724 <setDate+0x1d0>
			{
				d_year++;
     710:	1f 5f       	subi	r17, 0xFF	; 255
     712:	8f ef       	ldi	r24, 0xFF	; 255
     714:	91 ee       	ldi	r25, 0xE1	; 225
     716:	a4 e0       	ldi	r26, 0x04	; 4
     718:	81 50       	subi	r24, 0x01	; 1
     71a:	90 40       	sbci	r25, 0x00	; 0
     71c:	a0 40       	sbci	r26, 0x00	; 0
     71e:	e1 f7       	brne	.-8      	; 0x718 <setDate+0x1c4>
     720:	00 c0       	rjmp	.+0      	; 0x722 <setDate+0x1ce>
     722:	00 00       	nop
				_delay_ms(200);
			}
			if(util_IsBitCleared(Button, down))
     724:	84 99       	sbic	0x10, 4	; 16
     726:	0a c0       	rjmp	.+20     	; 0x73c <setDate+0x1e8>
			{
				d_year--;
     728:	11 50       	subi	r17, 0x01	; 1
     72a:	8f ef       	ldi	r24, 0xFF	; 255
     72c:	91 ee       	ldi	r25, 0xE1	; 225
     72e:	a4 e0       	ldi	r26, 0x04	; 4
     730:	81 50       	subi	r24, 0x01	; 1
     732:	90 40       	sbci	r25, 0x00	; 0
     734:	a0 40       	sbci	r26, 0x00	; 0
     736:	e1 f7       	brne	.-8      	; 0x730 <setDate+0x1dc>
     738:	00 c0       	rjmp	.+0      	; 0x73a <setDate+0x1e6>
     73a:	00 00       	nop
				_delay_ms(200);
			}
				
			if(d_year>=99)
     73c:	13 36       	cpi	r17, 0x63	; 99
     73e:	08 f0       	brcs	.+2      	; 0x742 <setDate+0x1ee>
			{
				d_year=0;
     740:	10 2f       	mov	r17, r16
			}
				
			LCD_Printf("%2d",d_year);
     742:	00 d0       	rcall	.+0      	; 0x744 <setDate+0x1f0>
     744:	00 d0       	rcall	.+0      	; 0x746 <setDate+0x1f2>
     746:	ed b7       	in	r30, 0x3d	; 61
     748:	fe b7       	in	r31, 0x3e	; 62
     74a:	31 96       	adiw	r30, 0x01	; 1
     74c:	ad b7       	in	r26, 0x3d	; 61
     74e:	be b7       	in	r27, 0x3e	; 62
     750:	12 96       	adiw	r26, 0x02	; 2
     752:	fc 92       	st	X, r15
     754:	ee 92       	st	-X, r14
     756:	11 97       	sbiw	r26, 0x01	; 1
     758:	12 83       	std	Z+2, r17	; 0x02
     75a:	13 82       	std	Z+3, r1	; 0x03
     75c:	86 d4       	rcall	.+2316   	; 0x106a <LCD_Printf>
				
				
		} while (util_IsBitSet(Button, select));
     75e:	0f 90       	pop	r0
     760:	0f 90       	pop	r0
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	83 99       	sbic	0x10, 3	; 16
     768:	c5 cf       	rjmp	.-118    	; 0x6f4 <setDate+0x1a0>
		while(util_IsBitCleared(Button,select));
     76a:	83 9b       	sbis	0x10, 3	; 16
     76c:	fe cf       	rjmp	.-4      	; 0x76a <setDate+0x216>
	   day = dec2bcd(d_day);
     76e:	8c 2f       	mov	r24, r28
     770:	e0 de       	rcall	.-576    	; 0x532 <dec2bcd>
     772:	08 2f       	mov	r16, r24
	   month = dec2bcd(d_month);
     774:	8d 2f       	mov	r24, r29
     776:	dd de       	rcall	.-582    	; 0x532 <dec2bcd>
     778:	c8 2f       	mov	r28, r24
	   year = dec2bcd(d_year);
     77a:	81 2f       	mov	r24, r17
     77c:	da de       	rcall	.-588    	; 0x532 <dec2bcd>
     77e:	48 2f       	mov	r20, r24
	   RTC_SetDate(day, month, year); 
     780:	80 2f       	mov	r24, r16
     782:	6c 2f       	mov	r22, r28
     784:	b3 d5       	rcall	.+2918   	; 0x12ec <RTC_SetDate>
	   LCD_Clear();
     786:	84 d2       	rcall	.+1288   	; 0xc90 <LCD_Clear>
	   LCD_DisplayString("Date Updated");
     788:	8f eb       	ldi	r24, 0xBF	; 191
     78a:	90 e0       	ldi	r25, 0x00	; 0
     78c:	60 d4       	rcall	.+2240   	; 0x104e <LCD_DisplayString>
     78e:	8f ef       	ldi	r24, 0xFF	; 255
     790:	93 ed       	ldi	r25, 0xD3	; 211
     792:	a0 e3       	ldi	r26, 0x30	; 48
     794:	81 50       	subi	r24, 0x01	; 1
     796:	90 40       	sbci	r25, 0x00	; 0
     798:	a0 40       	sbci	r26, 0x00	; 0
     79a:	e1 f7       	brne	.-8      	; 0x794 <setDate+0x240>
     79c:	00 c0       	rjmp	.+0      	; 0x79e <setDate+0x24a>
     79e:	00 00       	nop
	   _delay_ms(2000);
	  
}
     7a0:	df 91       	pop	r29
     7a2:	cf 91       	pop	r28
     7a4:	1f 91       	pop	r17
     7a6:	0f 91       	pop	r16
     7a8:	ff 90       	pop	r15
     7aa:	ef 90       	pop	r14
     7ac:	08 95       	ret

000007ae <setTime>:
	  while(util_IsBitCleared(Button,select)); //wait till button is released. 
	  return keycount;
}

void setTime(uint8_t hour, uint8_t min, uint8_t sec)
{  
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
     7b4:	1f 93       	push	r17
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
     7ba:	d6 2f       	mov	r29, r22
     7bc:	14 2f       	mov	r17, r20
	uint8_t d_hour, d_min, d_sec;
	uint8_t cnt=0;
	
	d_hour = bcd2dec(hour);
     7be:	bf de       	rcall	.-642    	; 0x53e <bcd2dec>
     7c0:	c8 2f       	mov	r28, r24
	d_min = bcd2dec(min);
     7c2:	8d 2f       	mov	r24, r29
     7c4:	bc de       	rcall	.-648    	; 0x53e <bcd2dec>
     7c6:	d8 2f       	mov	r29, r24
	d_sec = bcd2dec(sec);
     7c8:	81 2f       	mov	r24, r17
     7ca:	b9 de       	rcall	.-654    	; 0x53e <bcd2dec>
     7cc:	18 2f       	mov	r17, r24
	LCD_Clear();
     7ce:	60 d2       	rcall	.+1216   	; 0xc90 <LCD_Clear>
	LCD_GoToLine(1);
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	4f d2       	rcall	.+1182   	; 0xc72 <LCD_GoToLine>
	LCD_Printf("Hour  Min  sec");
     7d4:	00 d0       	rcall	.+0      	; 0x7d6 <setTime+0x28>
     7d6:	8c ec       	ldi	r24, 0xCC	; 204
     7d8:	90 e0       	ldi	r25, 0x00	; 0
     7da:	ad b7       	in	r26, 0x3d	; 61
     7dc:	be b7       	in	r27, 0x3e	; 62
     7de:	12 96       	adiw	r26, 0x02	; 2
     7e0:	9c 93       	st	X, r25
     7e2:	8e 93       	st	-X, r24
     7e4:	11 97       	sbiw	r26, 0x01	; 1
     7e6:	41 d4       	rcall	.+2178   	; 0x106a <LCD_Printf>
	LCD_GoToLine(2);
     7e8:	0f 90       	pop	r0
     7ea:	0f 90       	pop	r0
     7ec:	82 e0       	ldi	r24, 0x02	; 2
     7ee:	41 d2       	rcall	.+1154   	; 0xc72 <LCD_GoToLine>
	LCD_Printf("<%2d>  <%2d> <%2d>" , d_hour, d_min, d_sec);
     7f0:	ed b7       	in	r30, 0x3d	; 61
     7f2:	fe b7       	in	r31, 0x3e	; 62
     7f4:	38 97       	sbiw	r30, 0x08	; 8
     7f6:	0f b6       	in	r0, 0x3f	; 63
     7f8:	f8 94       	cli
     7fa:	fe bf       	out	0x3e, r31	; 62
     7fc:	0f be       	out	0x3f, r0	; 63
     7fe:	ed bf       	out	0x3d, r30	; 61
     800:	31 96       	adiw	r30, 0x01	; 1
     802:	88 ea       	ldi	r24, 0xA8	; 168
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	ad b7       	in	r26, 0x3d	; 61
     808:	be b7       	in	r27, 0x3e	; 62
     80a:	12 96       	adiw	r26, 0x02	; 2
     80c:	9c 93       	st	X, r25
     80e:	8e 93       	st	-X, r24
     810:	11 97       	sbiw	r26, 0x01	; 1
     812:	c2 83       	std	Z+2, r28	; 0x02
     814:	13 82       	std	Z+3, r1	; 0x03
     816:	d4 83       	std	Z+4, r29	; 0x04
     818:	15 82       	std	Z+5, r1	; 0x05
     81a:	16 83       	std	Z+6, r17	; 0x06
     81c:	17 82       	std	Z+7, r1	; 0x07
     81e:	25 d4       	rcall	.+2122   	; 0x106a <LCD_Printf>
     820:	ed b7       	in	r30, 0x3d	; 61
     822:	fe b7       	in	r31, 0x3e	; 62
     824:	38 96       	adiw	r30, 0x08	; 8
     826:	0f b6       	in	r0, 0x3f	; 63
     828:	f8 94       	cli
     82a:	fe bf       	out	0x3e, r31	; 62
     82c:	0f be       	out	0x3f, r0	; 63
     82e:	ed bf       	out	0x3d, r30	; 61
					_delay_ms(200);
				}
				
				if(d_hour>=24)
				{
					d_hour=0;
     830:	00 e0       	ldi	r16, 0x00	; 0
				}
				
				LCD_Printf("%2d",d_hour);
     832:	0f 2e       	mov	r0, r31
     834:	fb eb       	ldi	r31, 0xBB	; 187
     836:	ef 2e       	mov	r14, r31
     838:	f0 e0       	ldi	r31, 0x00	; 0
     83a:	ff 2e       	mov	r15, r31
     83c:	f0 2d       	mov	r31, r0
	LCD_GoToLine(2);
	LCD_Printf("<%2d>  <%2d> <%2d>" , d_hour, d_min, d_sec);

			
		do {	
			    LCD_SetCursor(2,1);
     83e:	82 e0       	ldi	r24, 0x02	; 2
     840:	61 e0       	ldi	r22, 0x01	; 1
     842:	ec d1       	rcall	.+984    	; 0xc1c <LCD_SetCursor>
     844:	8f ef       	ldi	r24, 0xFF	; 255
     846:	90 e7       	ldi	r25, 0x70	; 112
     848:	a2 e0       	ldi	r26, 0x02	; 2
     84a:	81 50       	subi	r24, 0x01	; 1
     84c:	90 40       	sbci	r25, 0x00	; 0
     84e:	a0 40       	sbci	r26, 0x00	; 0
     850:	e1 f7       	brne	.-8      	; 0x84a <setTime+0x9c>
     852:	00 c0       	rjmp	.+0      	; 0x854 <setTime+0xa6>
     854:	00 00       	nop
				_delay_ms(100);
				if(util_IsBitCleared(Button, up))
     856:	85 99       	sbic	0x10, 5	; 16
     858:	0a c0       	rjmp	.+20     	; 0x86e <setTime+0xc0>
				{
					d_hour++;
     85a:	cf 5f       	subi	r28, 0xFF	; 255
     85c:	8f ef       	ldi	r24, 0xFF	; 255
     85e:	91 ee       	ldi	r25, 0xE1	; 225
     860:	a4 e0       	ldi	r26, 0x04	; 4
     862:	81 50       	subi	r24, 0x01	; 1
     864:	90 40       	sbci	r25, 0x00	; 0
     866:	a0 40       	sbci	r26, 0x00	; 0
     868:	e1 f7       	brne	.-8      	; 0x862 <setTime+0xb4>
     86a:	00 c0       	rjmp	.+0      	; 0x86c <setTime+0xbe>
     86c:	00 00       	nop
					_delay_ms(200);
				}
				if(util_IsBitCleared(Button, down))
     86e:	84 99       	sbic	0x10, 4	; 16
     870:	0a c0       	rjmp	.+20     	; 0x886 <setTime+0xd8>
				{
					d_hour--;
     872:	c1 50       	subi	r28, 0x01	; 1
     874:	8f ef       	ldi	r24, 0xFF	; 255
     876:	91 ee       	ldi	r25, 0xE1	; 225
     878:	a4 e0       	ldi	r26, 0x04	; 4
     87a:	81 50       	subi	r24, 0x01	; 1
     87c:	90 40       	sbci	r25, 0x00	; 0
     87e:	a0 40       	sbci	r26, 0x00	; 0
     880:	e1 f7       	brne	.-8      	; 0x87a <setTime+0xcc>
     882:	00 c0       	rjmp	.+0      	; 0x884 <setTime+0xd6>
     884:	00 00       	nop
					_delay_ms(200);
				}
				
				if(d_hour>=24)
     886:	c8 31       	cpi	r28, 0x18	; 24
     888:	08 f0       	brcs	.+2      	; 0x88c <setTime+0xde>
				{
					d_hour=0;
     88a:	c0 2f       	mov	r28, r16
				}
				
				LCD_Printf("%2d",d_hour);
     88c:	00 d0       	rcall	.+0      	; 0x88e <setTime+0xe0>
     88e:	00 d0       	rcall	.+0      	; 0x890 <setTime+0xe2>
     890:	ed b7       	in	r30, 0x3d	; 61
     892:	fe b7       	in	r31, 0x3e	; 62
     894:	31 96       	adiw	r30, 0x01	; 1
     896:	ad b7       	in	r26, 0x3d	; 61
     898:	be b7       	in	r27, 0x3e	; 62
     89a:	12 96       	adiw	r26, 0x02	; 2
     89c:	fc 92       	st	X, r15
     89e:	ee 92       	st	-X, r14
     8a0:	11 97       	sbiw	r26, 0x01	; 1
     8a2:	c2 83       	std	Z+2, r28	; 0x02
     8a4:	13 82       	std	Z+3, r1	; 0x03
     8a6:	e1 d3       	rcall	.+1986   	; 0x106a <LCD_Printf>
				
		  } while (util_IsBitSet(Button, select));
     8a8:	0f 90       	pop	r0
     8aa:	0f 90       	pop	r0
     8ac:	0f 90       	pop	r0
     8ae:	0f 90       	pop	r0
     8b0:	83 99       	sbic	0x10, 3	; 16
     8b2:	c5 cf       	rjmp	.-118    	; 0x83e <setTime+0x90>
		  while(util_IsBitCleared(Button,select));
     8b4:	83 9b       	sbis	0x10, 3	; 16
     8b6:	fe cf       	rjmp	.-4      	; 0x8b4 <setTime+0x106>
				_delay_ms(200);
			}
			  	
			if(d_min>=60)
			{
				d_min=0;
     8b8:	00 e0       	ldi	r16, 0x00	; 0
			}
			  	
			LCD_Printf("%2d",d_min);
     8ba:	0f 2e       	mov	r0, r31
     8bc:	fb eb       	ldi	r31, 0xBB	; 187
     8be:	ef 2e       	mov	r14, r31
     8c0:	f0 e0       	ldi	r31, 0x00	; 0
     8c2:	ff 2e       	mov	r15, r31
     8c4:	f0 2d       	mov	r31, r0
		  
		  
		//update min  
		
		do {
			LCD_SetCursor(2,7);
     8c6:	82 e0       	ldi	r24, 0x02	; 2
     8c8:	67 e0       	ldi	r22, 0x07	; 7
     8ca:	a8 d1       	rcall	.+848    	; 0xc1c <LCD_SetCursor>
     8cc:	8f ef       	ldi	r24, 0xFF	; 255
     8ce:	90 e7       	ldi	r25, 0x70	; 112
     8d0:	a2 e0       	ldi	r26, 0x02	; 2
     8d2:	81 50       	subi	r24, 0x01	; 1
     8d4:	90 40       	sbci	r25, 0x00	; 0
     8d6:	a0 40       	sbci	r26, 0x00	; 0
     8d8:	e1 f7       	brne	.-8      	; 0x8d2 <setTime+0x124>
     8da:	00 c0       	rjmp	.+0      	; 0x8dc <setTime+0x12e>
     8dc:	00 00       	nop
			_delay_ms(100);
			if(util_IsBitCleared(Button, up))
     8de:	85 99       	sbic	0x10, 5	; 16
     8e0:	0a c0       	rjmp	.+20     	; 0x8f6 <setTime+0x148>
			{
				d_min++;
     8e2:	df 5f       	subi	r29, 0xFF	; 255
     8e4:	8f ef       	ldi	r24, 0xFF	; 255
     8e6:	91 ee       	ldi	r25, 0xE1	; 225
     8e8:	a4 e0       	ldi	r26, 0x04	; 4
     8ea:	81 50       	subi	r24, 0x01	; 1
     8ec:	90 40       	sbci	r25, 0x00	; 0
     8ee:	a0 40       	sbci	r26, 0x00	; 0
     8f0:	e1 f7       	brne	.-8      	; 0x8ea <setTime+0x13c>
     8f2:	00 c0       	rjmp	.+0      	; 0x8f4 <setTime+0x146>
     8f4:	00 00       	nop
				_delay_ms(200);
			}
			if(util_IsBitCleared(Button, down))
     8f6:	84 99       	sbic	0x10, 4	; 16
     8f8:	0a c0       	rjmp	.+20     	; 0x90e <setTime+0x160>
			{
				d_min--;
     8fa:	d1 50       	subi	r29, 0x01	; 1
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	91 ee       	ldi	r25, 0xE1	; 225
     900:	a4 e0       	ldi	r26, 0x04	; 4
     902:	81 50       	subi	r24, 0x01	; 1
     904:	90 40       	sbci	r25, 0x00	; 0
     906:	a0 40       	sbci	r26, 0x00	; 0
     908:	e1 f7       	brne	.-8      	; 0x902 <setTime+0x154>
     90a:	00 c0       	rjmp	.+0      	; 0x90c <setTime+0x15e>
     90c:	00 00       	nop
				_delay_ms(200);
			}
			  	
			if(d_min>=60)
     90e:	dc 33       	cpi	r29, 0x3C	; 60
     910:	08 f0       	brcs	.+2      	; 0x914 <setTime+0x166>
			{
				d_min=0;
     912:	d0 2f       	mov	r29, r16
			}
			  	
			LCD_Printf("%2d",d_min);
     914:	00 d0       	rcall	.+0      	; 0x916 <setTime+0x168>
     916:	00 d0       	rcall	.+0      	; 0x918 <setTime+0x16a>
     918:	ed b7       	in	r30, 0x3d	; 61
     91a:	fe b7       	in	r31, 0x3e	; 62
     91c:	31 96       	adiw	r30, 0x01	; 1
     91e:	ad b7       	in	r26, 0x3d	; 61
     920:	be b7       	in	r27, 0x3e	; 62
     922:	12 96       	adiw	r26, 0x02	; 2
     924:	fc 92       	st	X, r15
     926:	ee 92       	st	-X, r14
     928:	11 97       	sbiw	r26, 0x01	; 1
     92a:	d2 83       	std	Z+2, r29	; 0x02
     92c:	13 82       	std	Z+3, r1	; 0x03
     92e:	9d d3       	rcall	.+1850   	; 0x106a <LCD_Printf>
			  	
			  	
		} while (util_IsBitSet(Button, select));
     930:	0f 90       	pop	r0
     932:	0f 90       	pop	r0
     934:	0f 90       	pop	r0
     936:	0f 90       	pop	r0
     938:	83 99       	sbic	0x10, 3	; 16
     93a:	c5 cf       	rjmp	.-118    	; 0x8c6 <setTime+0x118>
		while(util_IsBitCleared(Button,select));
     93c:	83 9b       	sbis	0x10, 3	; 16
     93e:	fe cf       	rjmp	.-4      	; 0x93c <setTime+0x18e>
				_delay_ms(200);
			}
				
			if(d_sec>=60)
			{
				d_sec=0;
     940:	00 e0       	ldi	r16, 0x00	; 0
			}
				
			LCD_Printf("%2d",d_sec);
     942:	0f 2e       	mov	r0, r31
     944:	fb eb       	ldi	r31, 0xBB	; 187
     946:	ef 2e       	mov	r14, r31
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	ff 2e       	mov	r15, r31
     94c:	f0 2d       	mov	r31, r0
		while(util_IsBitCleared(Button,select));
		
		
		
		do {
			LCD_SetCursor(2,12);
     94e:	82 e0       	ldi	r24, 0x02	; 2
     950:	6c e0       	ldi	r22, 0x0C	; 12
     952:	64 d1       	rcall	.+712    	; 0xc1c <LCD_SetCursor>
     954:	8f ef       	ldi	r24, 0xFF	; 255
     956:	90 e7       	ldi	r25, 0x70	; 112
     958:	a2 e0       	ldi	r26, 0x02	; 2
     95a:	81 50       	subi	r24, 0x01	; 1
     95c:	90 40       	sbci	r25, 0x00	; 0
     95e:	a0 40       	sbci	r26, 0x00	; 0
     960:	e1 f7       	brne	.-8      	; 0x95a <setTime+0x1ac>
     962:	00 c0       	rjmp	.+0      	; 0x964 <setTime+0x1b6>
     964:	00 00       	nop
			_delay_ms(100);
			if(util_IsBitCleared(Button, up))
     966:	85 99       	sbic	0x10, 5	; 16
     968:	0a c0       	rjmp	.+20     	; 0x97e <setTime+0x1d0>
			{
				d_sec++;
     96a:	1f 5f       	subi	r17, 0xFF	; 255
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	91 ee       	ldi	r25, 0xE1	; 225
     970:	a4 e0       	ldi	r26, 0x04	; 4
     972:	81 50       	subi	r24, 0x01	; 1
     974:	90 40       	sbci	r25, 0x00	; 0
     976:	a0 40       	sbci	r26, 0x00	; 0
     978:	e1 f7       	brne	.-8      	; 0x972 <setTime+0x1c4>
     97a:	00 c0       	rjmp	.+0      	; 0x97c <setTime+0x1ce>
     97c:	00 00       	nop
				_delay_ms(200);
			}
			if(util_IsBitCleared(Button, down))
     97e:	84 99       	sbic	0x10, 4	; 16
     980:	0a c0       	rjmp	.+20     	; 0x996 <setTime+0x1e8>
			{
				d_sec--;
     982:	11 50       	subi	r17, 0x01	; 1
     984:	8f ef       	ldi	r24, 0xFF	; 255
     986:	91 ee       	ldi	r25, 0xE1	; 225
     988:	a4 e0       	ldi	r26, 0x04	; 4
     98a:	81 50       	subi	r24, 0x01	; 1
     98c:	90 40       	sbci	r25, 0x00	; 0
     98e:	a0 40       	sbci	r26, 0x00	; 0
     990:	e1 f7       	brne	.-8      	; 0x98a <setTime+0x1dc>
     992:	00 c0       	rjmp	.+0      	; 0x994 <setTime+0x1e6>
     994:	00 00       	nop
				_delay_ms(200);
			}
				
			if(d_sec>=60)
     996:	1c 33       	cpi	r17, 0x3C	; 60
     998:	08 f0       	brcs	.+2      	; 0x99c <setTime+0x1ee>
			{
				d_sec=0;
     99a:	10 2f       	mov	r17, r16
			}
				
			LCD_Printf("%2d",d_sec);
     99c:	00 d0       	rcall	.+0      	; 0x99e <setTime+0x1f0>
     99e:	00 d0       	rcall	.+0      	; 0x9a0 <setTime+0x1f2>
     9a0:	ed b7       	in	r30, 0x3d	; 61
     9a2:	fe b7       	in	r31, 0x3e	; 62
     9a4:	31 96       	adiw	r30, 0x01	; 1
     9a6:	ad b7       	in	r26, 0x3d	; 61
     9a8:	be b7       	in	r27, 0x3e	; 62
     9aa:	12 96       	adiw	r26, 0x02	; 2
     9ac:	fc 92       	st	X, r15
     9ae:	ee 92       	st	-X, r14
     9b0:	11 97       	sbiw	r26, 0x01	; 1
     9b2:	12 83       	std	Z+2, r17	; 0x02
     9b4:	13 82       	std	Z+3, r1	; 0x03
     9b6:	59 d3       	rcall	.+1714   	; 0x106a <LCD_Printf>
				
				
		} while (util_IsBitSet(Button, select));
     9b8:	0f 90       	pop	r0
     9ba:	0f 90       	pop	r0
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	83 99       	sbic	0x10, 3	; 16
     9c2:	c5 cf       	rjmp	.-118    	; 0x94e <setTime+0x1a0>
		while(util_IsBitCleared(Button,select));
     9c4:	83 9b       	sbis	0x10, 3	; 16
     9c6:	fe cf       	rjmp	.-4      	; 0x9c4 <setTime+0x216>
	   hour = dec2bcd(d_hour);
     9c8:	8c 2f       	mov	r24, r28
     9ca:	b3 dd       	rcall	.-1178   	; 0x532 <dec2bcd>
     9cc:	08 2f       	mov	r16, r24
	   min = dec2bcd(d_min);
     9ce:	8d 2f       	mov	r24, r29
     9d0:	b0 dd       	rcall	.-1184   	; 0x532 <dec2bcd>
     9d2:	c8 2f       	mov	r28, r24
	   sec = dec2bcd(d_sec);
     9d4:	81 2f       	mov	r24, r17
     9d6:	ad dd       	rcall	.-1190   	; 0x532 <dec2bcd>
     9d8:	48 2f       	mov	r20, r24
	   RTC_SetTime(hour, min, sec); 
     9da:	80 2f       	mov	r24, r16
     9dc:	6c 2f       	mov	r22, r28
     9de:	70 d4       	rcall	.+2272   	; 0x12c0 <RTC_SetTime>
	   LCD_Clear();
     9e0:	57 d1       	rcall	.+686    	; 0xc90 <LCD_Clear>
	   LCD_DisplayString("Time Updated");
     9e2:	8b ed       	ldi	r24, 0xDB	; 219
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	33 d3       	rcall	.+1638   	; 0x104e <LCD_DisplayString>
     9e8:	8f ef       	ldi	r24, 0xFF	; 255
     9ea:	93 ed       	ldi	r25, 0xD3	; 211
     9ec:	a0 e3       	ldi	r26, 0x30	; 48
     9ee:	81 50       	subi	r24, 0x01	; 1
     9f0:	90 40       	sbci	r25, 0x00	; 0
     9f2:	a0 40       	sbci	r26, 0x00	; 0
     9f4:	e1 f7       	brne	.-8      	; 0x9ee <setTime+0x240>
     9f6:	00 c0       	rjmp	.+0      	; 0x9f8 <setTime+0x24a>
     9f8:	00 00       	nop
	   _delay_ms(2000);
	  
}
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	1f 91       	pop	r17
     a00:	0f 91       	pop	r16
     a02:	ff 90       	pop	r15
     a04:	ef 90       	pop	r14
     a06:	08 95       	ret

00000a08 <main>:
uint8_t upcount=0, option=0;



void main()
{
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
     a0c:	00 d0       	rcall	.+0      	; 0xa0e <main+0x6>
     a0e:	00 d0       	rcall	.+0      	; 0xa10 <main+0x8>
     a10:	00 d0       	rcall	.+0      	; 0xa12 <main+0xa>
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
    #define up 5
    #define down 4
	#define select 3
	#define cancel 2
	
	DDRD = 0XF0; //Switches as input, lcd dataline as output
     a16:	80 ef       	ldi	r24, 0xF0	; 240
     a18:	81 bb       	out	0x11, r24	; 17
	PORTD = 0XFF; //Internal pull up enabled for switches
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	82 bb       	out	0x12, r24	; 18
	DDRB  |= (1<<buzzer_pin); // buzzer as output
     a1e:	bb 9a       	sbi	0x17, 3	; 23
	util_BitSet(buzzer_port,buzzer_pin);
     a20:	c3 9a       	sbi	0x18, 3	; 24
	
	uint8_t cnt =0;
	LCD_Init(4,2,16);
     a22:	84 e0       	ldi	r24, 0x04	; 4
     a24:	62 e0       	ldi	r22, 0x02	; 2
     a26:	40 e1       	ldi	r20, 0x10	; 16
     a28:	38 d1       	rcall	.+624    	; 0xc9a <LCD_Init>
	LCD_Printf("Explore Time!");
     a2a:	00 d0       	rcall	.+0      	; 0xa2c <main+0x24>
     a2c:	88 ee       	ldi	r24, 0xE8	; 232
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	ad b7       	in	r26, 0x3d	; 61
     a32:	be b7       	in	r27, 0x3e	; 62
     a34:	12 96       	adiw	r26, 0x02	; 2
     a36:	9c 93       	st	X, r25
     a38:	8e 93       	st	-X, r24
     a3a:	11 97       	sbiw	r26, 0x01	; 1
     a3c:	16 d3       	rcall	.+1580   	; 0x106a <LCD_Printf>
     a3e:	8f ef       	ldi	r24, 0xFF	; 255
     a40:	99 e6       	ldi	r25, 0x69	; 105
     a42:	a8 e1       	ldi	r26, 0x18	; 24
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	90 40       	sbci	r25, 0x00	; 0
     a48:	a0 40       	sbci	r26, 0x00	; 0
     a4a:	e1 f7       	brne	.-8      	; 0xa44 <main+0x3c>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <main+0x46>
     a4e:	00 00       	nop
	_delay_ms(1000);
    RTC_Init();
     a50:	0f 90       	pop	r0
     a52:	0f 90       	pop	r0
     a54:	2b d4       	rcall	.+2134   	; 0x12ac <RTC_Init>
	
	//segments for creating large font stored in RAM.
	
	LCD_CreateCC(LT,0);
     a56:	8e e7       	ldi	r24, 0x7E	; 126
     a58:	91 e0       	ldi	r25, 0x01	; 1
     a5a:	60 e0       	ldi	r22, 0x00	; 0
     a5c:	5e db       	rcall	.-2372   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(UB,1);
     a5e:	86 e7       	ldi	r24, 0x76	; 118
     a60:	91 e0       	ldi	r25, 0x01	; 1
     a62:	61 e0       	ldi	r22, 0x01	; 1
     a64:	5a db       	rcall	.-2380   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(RT,2);
     a66:	8e e6       	ldi	r24, 0x6E	; 110
     a68:	91 e0       	ldi	r25, 0x01	; 1
     a6a:	62 e0       	ldi	r22, 0x02	; 2
     a6c:	56 db       	rcall	.-2388   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(LL,3);
     a6e:	86 e6       	ldi	r24, 0x66	; 102
     a70:	91 e0       	ldi	r25, 0x01	; 1
     a72:	63 e0       	ldi	r22, 0x03	; 3
     a74:	52 db       	rcall	.-2396   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(LB,4);
     a76:	8e e5       	ldi	r24, 0x5E	; 94
     a78:	91 e0       	ldi	r25, 0x01	; 1
     a7a:	64 e0       	ldi	r22, 0x04	; 4
     a7c:	4e db       	rcall	.-2404   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(LR,5);
     a7e:	86 e5       	ldi	r24, 0x56	; 86
     a80:	91 e0       	ldi	r25, 0x01	; 1
     a82:	65 e0       	ldi	r22, 0x05	; 5
     a84:	4a db       	rcall	.-2412   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(UMB,6);
     a86:	8e e4       	ldi	r24, 0x4E	; 78
     a88:	91 e0       	ldi	r25, 0x01	; 1
     a8a:	66 e0       	ldi	r22, 0x06	; 6
     a8c:	46 db       	rcall	.-2420   	; 0x11a <LCD_CreateCC>
	LCD_CreateCC(LMB,7);
     a8e:	86 e4       	ldi	r24, 0x46	; 70
     a90:	91 e0       	ldi	r25, 0x01	; 1
     a92:	67 e0       	ldi	r22, 0x07	; 7
     a94:	42 db       	rcall	.-2428   	; 0x11a <LCD_CreateCC>
	//RTC_SetTime(0x12,0x57,0x20);  //  10:40:20 am
	//RTC_SetDate(0x03,0x03,0x15);  //  14th Nov 2012
	
	while(1){
		       
			  	if(util_IsBitCleared(Button,select))
     a96:	83 99       	sbic	0x10, 3	; 16
     a98:	18 c0       	rjmp	.+48     	; 0xaca <main+0xc2>
				 {   
					 while(util_IsBitCleared(Button,select));
     a9a:	83 9b       	sbis	0x10, 3	; 16
     a9c:	fe cf       	rjmp	.-4      	; 0xa9a <main+0x92>
					 option = LCD_DisplayMenu();
     a9e:	b0 dc       	rcall	.-1696   	; 0x400 <LCD_DisplayMenu>
     aa0:	80 93 8c 01 	sts	0x018C, r24
					 switch(option)
     aa4:	81 30       	cpi	r24, 0x01	; 1
     aa6:	51 f0       	breq	.+20     	; 0xabc <main+0xb4>
     aa8:	81 30       	cpi	r24, 0x01	; 1
     aaa:	18 f0       	brcs	.+6      	; 0xab2 <main+0xaa>
     aac:	82 30       	cpi	r24, 0x02	; 2
     aae:	61 f4       	brne	.+24     	; 0xac8 <main+0xc0>
     ab0:	0a c0       	rjmp	.+20     	; 0xac6 <main+0xbe>
					 {
						 case 0: setTime(hour,min,sec);break;
     ab2:	8b 81       	ldd	r24, Y+3	; 0x03
     ab4:	6a 81       	ldd	r22, Y+2	; 0x02
     ab6:	49 81       	ldd	r20, Y+1	; 0x01
     ab8:	7a de       	rcall	.-780    	; 0x7ae <setTime>
     aba:	06 c0       	rjmp	.+12     	; 0xac8 <main+0xc0>
						 case 1: setDate(day,month,year);break;
     abc:	8c 81       	ldd	r24, Y+4	; 0x04
     abe:	6d 81       	ldd	r22, Y+5	; 0x05
     ac0:	4e 81       	ldd	r20, Y+6	; 0x06
     ac2:	48 dd       	rcall	.-1392   	; 0x554 <setDate>
     ac4:	01 c0       	rjmp	.+2      	; 0xac8 <main+0xc0>
						 case 2: setAlarm(); break;
     ac6:	2a dd       	rcall	.-1452   	; 0x51c <setAlarm>
						 default: break;
					 }
					 
				 	LCD_Clear(); 	 
     ac8:	e3 d0       	rcall	.+454    	; 0xc90 <LCD_Clear>
				 }
			
			    RTC_GetTime(&hour,&min,&sec);      
     aca:	ce 01       	movw	r24, r28
     acc:	03 96       	adiw	r24, 0x03	; 3
     ace:	be 01       	movw	r22, r28
     ad0:	6e 5f       	subi	r22, 0xFE	; 254
     ad2:	7f 4f       	sbci	r23, 0xFF	; 255
     ad4:	ae 01       	movw	r20, r28
     ad6:	4f 5f       	subi	r20, 0xFF	; 255
     ad8:	5f 4f       	sbci	r21, 0xFF	; 255
     ada:	1e d4       	rcall	.+2108   	; 0x1318 <RTC_GetTime>
                RTC_GetDate(&day, &month, &year);// it is only read for updating not displayed				
     adc:	ce 01       	movw	r24, r28
     ade:	04 96       	adiw	r24, 0x04	; 4
     ae0:	be 01       	movw	r22, r28
     ae2:	6b 5f       	subi	r22, 0xFB	; 251
     ae4:	7f 4f       	sbci	r23, 0xFF	; 255
     ae6:	ae 01       	movw	r20, r28
     ae8:	4a 5f       	subi	r20, 0xFA	; 250
     aea:	5f 4f       	sbci	r21, 0xFF	; 255
     aec:	3a d4       	rcall	.+2164   	; 0x1362 <RTC_GetDate>
				LCD_DisplayTime(hour,min,sec);
     aee:	8b 81       	ldd	r24, Y+3	; 0x03
     af0:	6a 81       	ldd	r22, Y+2	; 0x02
     af2:	49 81       	ldd	r20, Y+1	; 0x01
     af4:	2a dc       	rcall	.-1964   	; 0x34a <LCD_DisplayTime>
				
				//LCD_DisplayString(settings[2]);
				//LCD_GoToLine(1);
				
			}
     af6:	cf cf       	rjmp	.-98     	; 0xa96 <main+0x8e>

00000af8 <DELAY_sec>:
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
     af8:	00 97       	sbiw	r24, 0x00	; 0
     afa:	59 f0       	breq	.+22     	; 0xb12 <DELAY_sec+0x1a>
     afc:	2f ef       	ldi	r18, 0xFF	; 255
     afe:	39 e6       	ldi	r19, 0x69	; 105
     b00:	48 e1       	ldi	r20, 0x18	; 24
     b02:	21 50       	subi	r18, 0x01	; 1
     b04:	30 40       	sbci	r19, 0x00	; 0
     b06:	40 40       	sbci	r20, 0x00	; 0
     b08:	e1 f7       	brne	.-8      	; 0xb02 <DELAY_sec+0xa>
     b0a:	00 c0       	rjmp	.+0      	; 0xb0c <DELAY_sec+0x14>
     b0c:	00 00       	nop
	  {
	     DELAY_ms(1000);	      /* DELAY_ms is called to generate 1sec delay */
		 var_delaySecCount_u16--;
     b0e:	01 97       	sbiw	r24, 0x01	; 1
      It generates a delay of 1sec for each count,
      if 10 is passed as the argument then it generates delay of 10sec
***************************************************************************************************/
void DELAY_sec(uint16_t var_delaySecCount_u16)
 {
	 while(var_delaySecCount_u16!=0)
     b10:	a9 f7       	brne	.-22     	; 0xafc <DELAY_sec+0x4>
     b12:	08 95       	ret

00000b14 <I2C_Init>:
 * description :This function is used to initialize the I2C module

------------------------------------------------------------------------------------*/
void I2C_Init()
{
  TWSR=0x00; //set presca1er bits to zero
     b14:	11 b8       	out	0x01, r1	; 1
  TWBR=0x50; //SCL frequency is 100K for XTAL = 7.3728M
     b16:	80 e5       	ldi	r24, 0x50	; 80
     b18:	80 b9       	out	0x00, r24	; 0
  TWCR=0x04; //enab1e TWI module
     b1a:	84 e0       	ldi	r24, 0x04	; 4
     b1c:	86 bf       	out	0x36, r24	; 54
}
     b1e:	08 95       	ret

00000b20 <I2C_Start>:
                      ____|         |____________

***************************************************************************************************/
void I2C_Start()
{
  TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
     b20:	84 ea       	ldi	r24, 0xA4	; 164
     b22:	86 bf       	out	0x36, r24	; 54
  while (!(TWCR & (1<<TWINT)));
     b24:	06 b6       	in	r0, 0x36	; 54
     b26:	07 fe       	sbrs	r0, 7
     b28:	fd cf       	rjmp	.-6      	; 0xb24 <I2C_Start+0x4>
}
     b2a:	08 95       	ret

00000b2c <I2C_Stop>:

***************************************************************************************************/

void I2C_Stop(void)
{
  TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
     b2c:	84 e9       	ldi	r24, 0x94	; 148
     b2e:	86 bf       	out	0x36, r24	; 54
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b30:	8a e1       	ldi	r24, 0x1A	; 26
     b32:	8a 95       	dec	r24
     b34:	f1 f7       	brne	.-4      	; 0xb32 <I2C_Stop+0x6>
     b36:	00 c0       	rjmp	.+0      	; 0xb38 <I2C_Stop+0xc>
   DELAY_us(10) ; //wait for a short time
}
     b38:	08 95       	ret

00000b3a <I2C_Write>:


***************************************************************************************************/
void I2C_Write(uint8_t var_i2cData_u8)
{
  TWDR = var_i2cData_u8 ;
     b3a:	83 b9       	out	0x03, r24	; 3
  TWCR = ((1<< TWINT) | (1<<TWEN));
     b3c:	84 e8       	ldi	r24, 0x84	; 132
     b3e:	86 bf       	out	0x36, r24	; 54
  while (!(TWCR & (1 <<TWINT)));
     b40:	06 b6       	in	r0, 0x36	; 54
     b42:	07 fe       	sbrs	r0, 7
     b44:	fd cf       	rjmp	.-6      	; 0xb40 <I2C_Write+0x6>
}
     b46:	08 95       	ret

00000b48 <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t var_ackOption_u8)
{
 TWCR = ((1<< TWINT) | (1<<TWEN) | (var_ackOption_u8<<TWEA));
     b48:	82 95       	swap	r24
     b4a:	88 0f       	add	r24, r24
     b4c:	88 0f       	add	r24, r24
     b4e:	80 7c       	andi	r24, 0xC0	; 192
     b50:	84 68       	ori	r24, 0x84	; 132
     b52:	86 bf       	out	0x36, r24	; 54
   while ( !(TWCR & (1 <<TWINT)));
     b54:	06 b6       	in	r0, 0x36	; 54
     b56:	07 fe       	sbrs	r0, 7
     b58:	fd cf       	rjmp	.-6      	; 0xb54 <I2C_Read+0xc>
   return TWDR;
     b5a:	83 b1       	in	r24, 0x03	; 3
}
     b5c:	08 95       	ret

00000b5e <lcd_SendNibble>:

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 *************************************************************************************************/
static void lcd_SendNibble(uint8_t var)
{
	util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
     b5e:	98 2f       	mov	r25, r24
     b60:	84 ff       	sbrs	r24, 4
     b62:	02 c0       	rjmp	.+4      	; 0xb68 <lcd_SendNibble+0xa>
     b64:	c4 9a       	sbi	0x18, 4	; 24
     b66:	01 c0       	rjmp	.+2      	; 0xb6a <lcd_SendNibble+0xc>
     b68:	c4 98       	cbi	0x18, 4	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
     b6a:	95 ff       	sbrs	r25, 5
     b6c:	02 c0       	rjmp	.+4      	; 0xb72 <lcd_SendNibble+0x14>
     b6e:	c5 9a       	sbi	0x18, 5	; 24
     b70:	01 c0       	rjmp	.+2      	; 0xb74 <lcd_SendNibble+0x16>
     b72:	c5 98       	cbi	0x18, 5	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
     b74:	96 ff       	sbrs	r25, 6
     b76:	02 c0       	rjmp	.+4      	; 0xb7c <lcd_SendNibble+0x1e>
     b78:	c6 9a       	sbi	0x18, 6	; 24
     b7a:	01 c0       	rjmp	.+2      	; 0xb7e <lcd_SendNibble+0x20>
     b7c:	c6 98       	cbi	0x18, 6	; 24
	util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
     b7e:	88 23       	and	r24, r24
     b80:	14 f4       	brge	.+4      	; 0xb86 <lcd_SendNibble+0x28>
     b82:	c7 9a       	sbi	0x18, 7	; 24
     b84:	08 95       	ret
     b86:	c7 98       	cbi	0x18, 7	; 24
     b88:	08 95       	ret

00000b8a <lcd_BusyCheck>:
static void lcd_BusyCheck()
{
	uint8_t busyflag;
#ifdef LCD_RW       //Perform Busy check if LCD_RW pin is used

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
     b8a:	bf 98       	cbi	0x17, 7	; 23
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
     b8c:	c0 98       	cbi	0x18, 0	; 24
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
     b8e:	c1 9a       	sbi	0x18, 1	; 24
		M_LcdSetBit(LCD_EN); 
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
     b90:	e3 e9       	ldi	r30, 0x93	; 147
     b92:	f1 e0       	ldi	r31, 0x01	; 1
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
	M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
	do
	{

		M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
     b94:	c2 98       	cbi	0x18, 2	; 24
     b96:	8a e1       	ldi	r24, 0x1A	; 26
     b98:	8a 95       	dec	r24
     b9a:	f1 f7       	brne	.-4      	; 0xb98 <lcd_BusyCheck+0xe>
     b9c:	00 c0       	rjmp	.+0      	; 0xb9e <lcd_BusyCheck+0x14>
		DELAY_us(10);	
		M_LcdSetBit(LCD_EN); 
     b9e:	c2 9a       	sbi	0x18, 2	; 24
     ba0:	9a e1       	ldi	r25, 0x1A	; 26
     ba2:	9a 95       	dec	r25
     ba4:	f1 f7       	brne	.-4      	; 0xba2 <lcd_BusyCheck+0x18>
     ba6:	00 c0       	rjmp	.+0      	; 0xba8 <lcd_BusyCheck+0x1e>
		DELAY_us(10);
		busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
     ba8:	86 b3       	in	r24, 0x16	; 22


		if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
     baa:	90 81       	ld	r25, Z
     bac:	94 30       	cpi	r25, 0x04	; 4
     bae:	51 f4       	brne	.+20     	; 0xbc4 <lcd_BusyCheck+0x3a>
		{
			/* Perform extra dummy read for 4-bit */ 	   	
			M_LcdClearBit(LCD_EN);
     bb0:	c2 98       	cbi	0x18, 2	; 24
     bb2:	9a e1       	ldi	r25, 0x1A	; 26
     bb4:	9a 95       	dec	r25
     bb6:	f1 f7       	brne	.-4      	; 0xbb4 <lcd_BusyCheck+0x2a>
     bb8:	00 c0       	rjmp	.+0      	; 0xbba <lcd_BusyCheck+0x30>
			DELAY_us(10);
			M_LcdSetBit(LCD_EN); 
     bba:	c2 9a       	sbi	0x18, 2	; 24
     bbc:	9a e1       	ldi	r25, 0x1A	; 26
     bbe:	9a 95       	dec	r25
     bc0:	f1 f7       	brne	.-4      	; 0xbbe <lcd_BusyCheck+0x34>
     bc2:	00 c0       	rjmp	.+0      	; 0xbc4 <lcd_BusyCheck+0x3a>
			DELAY_us(10);
		}	
	}while(busyflag);
     bc4:	88 23       	and	r24, r24
     bc6:	34 f3       	brlt	.-52     	; 0xb94 <lcd_BusyCheck+0xa>

	util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
     bc8:	bf 9a       	sbi	0x17, 7	; 23
#else
	/* Busy flag cannot be read as LCD_RW is not available hence Extra delay of 1ms is added 
	  to ensure the LCD completes previous operation and ready to receive new commands/data */
	DELAY_ms(1);  
#endif
}
     bca:	08 95       	ret

00000bcc <lcd_SendCmdSignals>:

 * description : This functions generates the signals for sending the var_lcdCmd_u8 to LCD
 *************************************************************************************************/
static void lcd_SendCmdSignals()
{
	M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
     bcc:	c0 98       	cbi	0x18, 0	; 24
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
     bce:	c1 98       	cbi	0x18, 1	; 24
#endif
	M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
     bd0:	c2 9a       	sbi	0x18, 2	; 24
     bd2:	8a e1       	ldi	r24, 0x1A	; 26
     bd4:	8a 95       	dec	r24
     bd6:	f1 f7       	brne	.-4      	; 0xbd4 <lcd_SendCmdSignals+0x8>
     bd8:	00 c0       	rjmp	.+0      	; 0xbda <lcd_SendCmdSignals+0xe>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
     bda:	c2 98       	cbi	0x18, 2	; 24
}
     bdc:	08 95       	ret

00000bde <lcd_SendDataSignals>:

 * description : This functions generates the signals for sending the Data to LCD
 *************************************************************************************************/
static void lcd_SendDataSignals()
{
	M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
     bde:	c0 9a       	sbi	0x18, 0	; 24
#ifdef LCD_RW
	M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
     be0:	c1 98       	cbi	0x18, 1	; 24
#endif
	M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
     be2:	c2 9a       	sbi	0x18, 2	; 24
     be4:	8a e1       	ldi	r24, 0x1A	; 26
     be6:	8a 95       	dec	r24
     be8:	f1 f7       	brne	.-4      	; 0xbe6 <lcd_SendDataSignals+0x8>
     bea:	00 c0       	rjmp	.+0      	; 0xbec <lcd_SendDataSignals+0xe>
	DELAY_us(10);
	M_LcdClearBit(LCD_EN);
     bec:	c2 98       	cbi	0x18, 2	; 24
}
     bee:	08 95       	ret

00000bf0 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.				
				The behaviour is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
{
     bf0:	cf 93       	push	r28
     bf2:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
     bf4:	ca df       	rcall	.-108    	; 0xb8a <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
     bf6:	80 91 93 01 	lds	r24, 0x0193
     bfa:	88 30       	cpi	r24, 0x08	; 8
     bfc:	19 f4       	brne	.+6      	; 0xc04 <LCD_CmdWrite+0x14>
	{

		M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
     bfe:	c8 bb       	out	0x18, r28	; 24
		lcd_SendCmdSignals();  // Signals for command write operation
     c00:	e5 df       	rcall	.-54     	; 0xbcc <lcd_SendCmdSignals>
     c02:	0a c0       	rjmp	.+20     	; 0xc18 <LCD_CmdWrite+0x28>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
     c04:	84 30       	cpi	r24, 0x04	; 4
     c06:	41 f4       	brne	.+16     	; 0xc18 <LCD_CmdWrite+0x28>
	{
		lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
     c08:	8c 2f       	mov	r24, r28
     c0a:	a9 df       	rcall	.-174    	; 0xb5e <lcd_SendNibble>
		lcd_SendCmdSignals(); // Signals for command write operation
     c0c:	df df       	rcall	.-66     	; 0xbcc <lcd_SendCmdSignals>

		lcd_SendNibble(var_lcdCmd_u8 << 4);
     c0e:	8c 2f       	mov	r24, r28
     c10:	82 95       	swap	r24
     c12:	80 7f       	andi	r24, 0xF0	; 240
     c14:	a4 df       	rcall	.-184    	; 0xb5e <lcd_SendNibble>
		lcd_SendCmdSignals();
     c16:	da df       	rcall	.-76     	; 0xbcc <lcd_SendCmdSignals>
	}
}
     c18:	cf 91       	pop	r28
     c1a:	08 95       	ret

00000c1c <LCD_SetCursor>:
 ***************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t var_lineNumber_u8, uint8_t var_charNumber_u8)
{

	if((var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8) &&
     c1c:	90 91 91 01 	lds	r25, 0x0191
     c20:	98 17       	cp	r25, r24
     c22:	78 f0       	brcs	.+30     	; 0xc42 <LCD_SetCursor+0x26>
     c24:	90 91 92 01 	lds	r25, 0x0192
     c28:	69 17       	cp	r22, r25
     c2a:	58 f4       	brcc	.+22     	; 0xc42 <LCD_SetCursor+0x26>
			(var_charNumber_u8< STK_LCDConfig.mvar_MaxSupportedChars_U8))
	{
		/*If the line number and char are in range then
		   move the Cursor to specified Position*/
		VAR_LcdTrackCursorPos_U8 = var_charNumber_u8;
     c2c:	60 93 8f 01 	sts	0x018F, r22
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
     c30:	80 93 90 01 	sts	0x0190, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]+var_charNumber_u8);
     c34:	e6 e8       	ldi	r30, 0x86	; 134
     c36:	f1 e0       	ldi	r31, 0x01	; 1
     c38:	e8 0f       	add	r30, r24
     c3a:	f1 1d       	adc	r31, r1
     c3c:	80 81       	ld	r24, Z
     c3e:	86 0f       	add	r24, r22
     c40:	d7 df       	rcall	.-82     	; 0xbf0 <LCD_CmdWrite>
     c42:	08 95       	ret

00000c44 <LCD_GoToNextLine>:
 ***************************************************************************************************/
void  LCD_GoToNextLine()
{
	/*Increment the current line number.
	  In case it exceeds the limit, rool it back to first line */
	VAR_LcdTrackLineNum_U8++;
     c44:	80 91 90 01 	lds	r24, 0x0190
     c48:	8f 5f       	subi	r24, 0xFF	; 255
     c4a:	80 93 90 01 	sts	0x0190, r24
	VAR_LcdTrackCursorPos_U8 = 0x00;
     c4e:	10 92 8f 01 	sts	0x018F, r1
	if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
     c52:	90 91 91 01 	lds	r25, 0x0191
     c56:	98 17       	cp	r25, r24
     c58:	18 f4       	brcc	.+6      	; 0xc60 <LCD_GoToNextLine+0x1c>
		VAR_LcdTrackLineNum_U8 = 0x01;
     c5a:	81 e0       	ldi	r24, 0x01	; 1
     c5c:	80 93 90 01 	sts	0x0190, r24
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
     c60:	80 91 90 01 	lds	r24, 0x0190
     c64:	e6 e8       	ldi	r30, 0x86	; 134
     c66:	f1 e0       	ldi	r31, 0x01	; 1
     c68:	e8 0f       	add	r30, r24
     c6a:	f1 1d       	adc	r31, r1
     c6c:	80 81       	ld	r24, Z
     c6e:	c0 df       	rcall	.-128    	; 0xbf0 <LCD_CmdWrite>
}
     c70:	08 95       	ret

00000c72 <LCD_GoToLine>:
           mENUM_LcdLineThree,
           mENUM_LcdLineFour,
 ***************************************************************************************************/
void LCD_GoToLine(uint8_t var_lineNumber_u8)
{
	if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
     c72:	90 91 91 01 	lds	r25, 0x0191
     c76:	98 17       	cp	r25, r24
     c78:	50 f0       	brcs	.+20     	; 0xc8e <LCD_GoToLine+0x1c>
	{
		/* If the line number is within range then
	       Move the Cursor to beginning of the specified line */
		VAR_LcdTrackCursorPos_U8 = 0x00;
     c7a:	10 92 8f 01 	sts	0x018F, r1
		VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
     c7e:	80 93 90 01 	sts	0x0190, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
     c82:	e6 e8       	ldi	r30, 0x86	; 134
     c84:	f1 e0       	ldi	r31, 0x01	; 1
     c86:	e8 0f       	add	r30, r24
     c88:	f1 1d       	adc	r31, r1
     c8a:	80 81       	ld	r24, Z
     c8c:	b1 df       	rcall	.-158    	; 0xbf0 <LCD_CmdWrite>
     c8e:	08 95       	ret

00000c90 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ***************************************************************************************************/
void LCD_Clear()
{
	LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	ae df       	rcall	.-164    	; 0xbf0 <LCD_CmdWrite>
	LCD_GoToLine(mENUM_LcdLineOne);
     c94:	81 e0       	ldi	r24, 0x01	; 1
     c96:	ed df       	rcall	.-38     	; 0xc72 <LCD_GoToLine>
}
     c98:	08 95       	ret

00000c9a <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
{


	M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
     c9a:	9f ef       	ldi	r25, 0xFF	; 255
     c9c:	97 bb       	out	0x17, r25	; 23
	M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
     c9e:	97 bb       	out	0x17, r25	; 23
	STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
     ca0:	80 93 93 01 	sts	0x0193, r24
	STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
     ca4:	40 93 92 01 	sts	0x0192, r20
	STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
     ca8:	60 93 91 01 	sts	0x0191, r22
	if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
     cac:	63 30       	cpi	r22, 0x03	; 3
     cae:	40 f0       	brcs	.+16     	; 0xcc0 <LCD_Init+0x26>
	{
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
     cb0:	4f 70       	andi	r20, 0x0F	; 15
     cb2:	84 2f       	mov	r24, r20
     cb4:	80 57       	subi	r24, 0x70	; 112
     cb6:	80 93 89 01 	sts	0x0189, r24
		ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
     cba:	40 53       	subi	r20, 0x30	; 48
     cbc:	40 93 8a 01 	sts	0x018A, r20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	90 e7       	ldi	r25, 0x70	; 112
     cc4:	a2 e0       	ldi	r26, 0x02	; 2
     cc6:	81 50       	subi	r24, 0x01	; 1
     cc8:	90 40       	sbci	r25, 0x00	; 0
     cca:	a0 40       	sbci	r26, 0x00	; 0
     ccc:	e1 f7       	brne	.-8      	; 0xcc6 <LCD_Init+0x2c>
     cce:	00 c0       	rjmp	.+0      	; 0xcd0 <LCD_Init+0x36>
     cd0:	00 00       	nop
	}

	DELAY_ms(100);

	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
     cd2:	80 91 93 01 	lds	r24, 0x0193
     cd6:	88 30       	cpi	r24, 0x08	; 8
     cd8:	19 f4       	brne	.+6      	; 0xce0 <LCD_Init+0x46>
	{
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
     cda:	88 e3       	ldi	r24, 0x38	; 56
     cdc:	89 df       	rcall	.-238    	; 0xbf0 <LCD_CmdWrite>
     cde:	2b c0       	rjmp	.+86     	; 0xd36 <LCD_Init+0x9c>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
     ce0:	84 30       	cpi	r24, 0x04	; 4
     ce2:	49 f5       	brne	.+82     	; 0xd36 <LCD_Init+0x9c>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset()
{
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendNibble(0x30);
     ce4:	80 e3       	ldi	r24, 0x30	; 48
     ce6:	3b df       	rcall	.-394    	; 0xb5e <lcd_SendNibble>
	lcd_SendCmdSignals();
     ce8:	71 df       	rcall	.-286    	; 0xbcc <lcd_SendCmdSignals>
     cea:	8f ef       	ldi	r24, 0xFF	; 255
     cec:	90 e7       	ldi	r25, 0x70	; 112
     cee:	a2 e0       	ldi	r26, 0x02	; 2
     cf0:	81 50       	subi	r24, 0x01	; 1
     cf2:	90 40       	sbci	r25, 0x00	; 0
     cf4:	a0 40       	sbci	r26, 0x00	; 0
     cf6:	e1 f7       	brne	.-8      	; 0xcf0 <LCD_Init+0x56>
     cf8:	00 c0       	rjmp	.+0      	; 0xcfa <LCD_Init+0x60>
     cfa:	00 00       	nop
	DELAY_ms(100);
	lcd_SendNibble(0x30);
     cfc:	80 e3       	ldi	r24, 0x30	; 48
     cfe:	2f df       	rcall	.-418    	; 0xb5e <lcd_SendNibble>
	lcd_SendCmdSignals();
     d00:	65 df       	rcall	.-310    	; 0xbcc <lcd_SendCmdSignals>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     d02:	af e8       	ldi	r26, 0x8F	; 143
     d04:	b1 e0       	ldi	r27, 0x01	; 1
     d06:	11 97       	sbiw	r26, 0x01	; 1
     d08:	f1 f7       	brne	.-4      	; 0xd06 <LCD_Init+0x6c>
     d0a:	00 c0       	rjmp	.+0      	; 0xd0c <LCD_Init+0x72>
     d0c:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x30);
     d0e:	80 e3       	ldi	r24, 0x30	; 48
     d10:	26 df       	rcall	.-436    	; 0xb5e <lcd_SendNibble>
	lcd_SendCmdSignals();
     d12:	5c df       	rcall	.-328    	; 0xbcc <lcd_SendCmdSignals>
     d14:	8f e8       	ldi	r24, 0x8F	; 143
     d16:	91 e0       	ldi	r25, 0x01	; 1
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	f1 f7       	brne	.-4      	; 0xd18 <LCD_Init+0x7e>
     d1c:	00 c0       	rjmp	.+0      	; 0xd1e <LCD_Init+0x84>
     d1e:	00 00       	nop
	DELAY_us(200);
	lcd_SendNibble(0x20);
     d20:	80 e2       	ldi	r24, 0x20	; 32
     d22:	1d df       	rcall	.-454    	; 0xb5e <lcd_SendNibble>
	lcd_SendCmdSignals();
     d24:	53 df       	rcall	.-346    	; 0xbcc <lcd_SendCmdSignals>
     d26:	af e8       	ldi	r26, 0x8F	; 143
     d28:	b1 e0       	ldi	r27, 0x01	; 1
     d2a:	11 97       	sbiw	r26, 0x01	; 1
     d2c:	f1 f7       	brne	.-4      	; 0xd2a <LCD_Init+0x90>
     d2e:	00 c0       	rjmp	.+0      	; 0xd30 <LCD_Init+0x96>
     d30:	00 00       	nop
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
	{
		lcd_Reset();
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
     d32:	88 e2       	ldi	r24, 0x28	; 40
     d34:	5d df       	rcall	.-326    	; 0xbf0 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_BLINK);	 // Display ON cursor ON
     d36:	8f e0       	ldi	r24, 0x0F	; 15
     d38:	5b df       	rcall	.-330    	; 0xbf0 <LCD_CmdWrite>
	LCD_Clear();	                         // Clear the LCD and go to First line First Position
     d3a:	aa df       	rcall	.-172    	; 0xc90 <LCD_Clear>
}
     d3c:	08 95       	ret

00000d3e <lcd_DataWrite>:
 * Return value	: none

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
void lcd_DataWrite( uint8_t dat)
{
     d3e:	cf 93       	push	r28
     d40:	c8 2f       	mov	r28, r24
	lcd_BusyCheck();
     d42:	23 df       	rcall	.-442    	; 0xb8a <lcd_BusyCheck>
	if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
     d44:	80 91 93 01 	lds	r24, 0x0193
     d48:	88 30       	cpi	r24, 0x08	; 8
     d4a:	19 f4       	brne	.+6      	; 0xd52 <lcd_DataWrite+0x14>
	{
		M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
     d4c:	c8 bb       	out	0x18, r28	; 24
		lcd_SendDataSignals();  // Signals for data write operation
     d4e:	47 df       	rcall	.-370    	; 0xbde <lcd_SendDataSignals>
     d50:	0a c0       	rjmp	.+20     	; 0xd66 <lcd_DataWrite+0x28>
	}
	else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
     d52:	84 30       	cpi	r24, 0x04	; 4
     d54:	41 f4       	brne	.+16     	; 0xd66 <lcd_DataWrite+0x28>
	{
		lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
     d56:	8c 2f       	mov	r24, r28
     d58:	02 df       	rcall	.-508    	; 0xb5e <lcd_SendNibble>
		lcd_SendDataSignals();  // Signals for data write operation
     d5a:	41 df       	rcall	.-382    	; 0xbde <lcd_SendDataSignals>

		lcd_SendNibble(dat << 4);
     d5c:	8c 2f       	mov	r24, r28
     d5e:	82 95       	swap	r24
     d60:	80 7f       	andi	r24, 0xF0	; 240
     d62:	fd de       	rcall	.-518    	; 0xb5e <lcd_SendNibble>
		lcd_SendDataSignals();
     d64:	3c df       	rcall	.-392    	; 0xbde <lcd_SendDataSignals>
	}
}
     d66:	cf 91       	pop	r28
     d68:	08 95       	ret

00000d6a <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
void LCD_DisplayChar(char var_lcdData_u8)
{
     d6a:	cf 93       	push	r28
     d6c:	c8 2f       	mov	r28, r24
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
     d6e:	90 91 92 01 	lds	r25, 0x0192
     d72:	80 91 8f 01 	lds	r24, 0x018F
     d76:	89 17       	cp	r24, r25
     d78:	18 f4       	brcc	.+6      	; 0xd80 <LCD_DisplayChar+0x16>
     d7a:	ca 30       	cpi	r28, 0x0A	; 10
     d7c:	21 f4       	brne	.+8      	; 0xd86 <LCD_DisplayChar+0x1c>
     d7e:	0b c0       	rjmp	.+22     	; 0xd96 <LCD_DisplayChar+0x2c>
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
     d80:	61 df       	rcall	.-318    	; 0xc44 <LCD_GoToNextLine>
	}
	if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
     d82:	ca 30       	cpi	r28, 0x0A	; 10
     d84:	49 f0       	breq	.+18     	; 0xd98 <LCD_DisplayChar+0x2e>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
     d86:	8c 2f       	mov	r24, r28
     d88:	da df       	rcall	.-76     	; 0xd3e <lcd_DataWrite>
		VAR_LcdTrackCursorPos_U8++;
     d8a:	80 91 8f 01 	lds	r24, 0x018F
     d8e:	8f 5f       	subi	r24, 0xFF	; 255
     d90:	80 93 8f 01 	sts	0x018F, r24
     d94:	01 c0       	rjmp	.+2      	; 0xd98 <LCD_DisplayChar+0x2e>
{
	if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
	{
		/* If the cursor has reached to end of line on page1
		OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
     d96:	56 df       	rcall	.-340    	; 0xc44 <LCD_GoToNextLine>
	{

		lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
		VAR_LcdTrackCursorPos_U8++;
	}
}
     d98:	cf 91       	pop	r28
     d9a:	08 95       	ret

00000d9c <LCD_DisplayBinaryNumber>:
				2.(10,8) then 8-LSB will be displayed ie. 00001010
				3.(10,2) then 2-LSB will be displayed ie. 10
 *************************************************************************************************/
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
     d9c:	bf 92       	push	r11
     d9e:	cf 92       	push	r12
     da0:	df 92       	push	r13
     da2:	ef 92       	push	r14
     da4:	ff 92       	push	r15
     da6:	0f 93       	push	r16
     da8:	1f 93       	push	r17
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
     dae:	6b 01       	movw	r12, r22
     db0:	7c 01       	movw	r14, r24
     db2:	c4 2f       	mov	r28, r20
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
     db4:	44 23       	and	r20, r20
     db6:	11 f1       	breq	.+68     	; 0xdfc <LCD_DisplayBinaryNumber+0x60>
	{
		/* Start Extracting the bits from the specified bit positions.
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
     db8:	01 e0       	ldi	r16, 0x01	; 1
     dba:	10 e0       	ldi	r17, 0x00	; 0
     dbc:	d1 e0       	ldi	r29, 0x01	; 1
     dbe:	bb 24       	eor	r11, r11
     dc0:	4c 2f       	mov	r20, r28
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	41 50       	subi	r20, 0x01	; 1
     dc6:	50 40       	sbci	r21, 0x00	; 0
     dc8:	c8 01       	movw	r24, r16
     dca:	02 c0       	rjmp	.+4      	; 0xdd0 <LCD_DisplayBinaryNumber+0x34>
     dcc:	88 0f       	add	r24, r24
     dce:	99 1f       	adc	r25, r25
     dd0:	4a 95       	dec	r20
     dd2:	e2 f7       	brpl	.-8      	; 0xdcc <LCD_DisplayBinaryNumber+0x30>
     dd4:	ac 01       	movw	r20, r24
     dd6:	66 27       	eor	r22, r22
     dd8:	57 fd       	sbrc	r21, 7
     dda:	60 95       	com	r22
     ddc:	76 2f       	mov	r23, r22
     dde:	4c 21       	and	r20, r12
     de0:	5d 21       	and	r21, r13
     de2:	6e 21       	and	r22, r14
     de4:	7f 21       	and	r23, r15
     de6:	8d 2f       	mov	r24, r29
     de8:	41 15       	cp	r20, r1
     dea:	51 05       	cpc	r21, r1
     dec:	61 05       	cpc	r22, r1
     dee:	71 05       	cpc	r23, r1
     df0:	09 f4       	brne	.+2      	; 0xdf4 <LCD_DisplayBinaryNumber+0x58>
     df2:	8b 2d       	mov	r24, r11
		LCD_DisplayChar(util_Dec2Ascii(ch));
     df4:	80 5d       	subi	r24, 0xD0	; 208
     df6:	b9 df       	rcall	.-142    	; 0xd6a <LCD_DisplayChar>
		var_numOfBitsToDisplay_u8--;
     df8:	c1 50       	subi	r28, 0x01	; 1
#if (Enable_LCD_DisplayBinaryNumber == 1)
void LCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
	uint8_t ch;
	  
	while(var_numOfBitsToDisplay_u8!=0)
     dfa:	11 f7       	brne	.-60     	; 0xdc0 <LCD_DisplayBinaryNumber+0x24>
	     Get the Acsii values of the bits and display */
		ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
		LCD_DisplayChar(util_Dec2Ascii(ch));
		var_numOfBitsToDisplay_u8--;
	}
}
     dfc:	df 91       	pop	r29
     dfe:	cf 91       	pop	r28
     e00:	1f 91       	pop	r17
     e02:	0f 91       	pop	r16
     e04:	ff 90       	pop	r15
     e06:	ef 90       	pop	r14
     e08:	df 90       	pop	r13
     e0a:	cf 90       	pop	r12
     e0c:	bf 90       	pop	r11
     e0e:	08 95       	ret

00000e10 <LCD_DisplayHexNumber>:
				2.(0x12AB,6) then 6-digits ie. 0012AB will be displayed
				3.(0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ***************************************************************************************************/
#if ( Enable_LCD_DisplayHexNumber == 1 ) 
void LCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
     e10:	1f 93       	push	r17
     e12:	cf 93       	push	r28
     e14:	df 93       	push	r29
     e16:	cd b7       	in	r28, 0x3d	; 61
     e18:	de b7       	in	r29, 0x3e	; 62
     e1a:	2a 97       	sbiw	r28, 0x0a	; 10
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	f8 94       	cli
     e20:	de bf       	out	0x3e, r29	; 62
     e22:	0f be       	out	0x3f, r0	; 63
     e24:	cd bf       	out	0x3d, r28	; 61
     e26:	dc 01       	movw	r26, r24
     e28:	cb 01       	movw	r24, r22
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
     e2a:	00 97       	sbiw	r24, 0x00	; 0
     e2c:	a1 05       	cpc	r26, r1
     e2e:	b1 05       	cpc	r27, r1
     e30:	19 f0       	breq	.+6      	; 0xe38 <LCD_DisplayHexNumber+0x28>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     e32:	44 23       	and	r20, r20
     e34:	69 f4       	brne	.+26     	; 0xe50 <LCD_DisplayHexNumber+0x40>
     e36:	35 c0       	rjmp	.+106    	; 0xea2 <LCD_DisplayHexNumber+0x92>
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
     e38:	44 23       	and	r20, r20
     e3a:	99 f1       	breq	.+102    	; 0xea2 <LCD_DisplayHexNumber+0x92>
     e3c:	fe 01       	movw	r30, r28
     e3e:	31 96       	adiw	r30, 0x01	; 1
     e40:	10 e0       	ldi	r17, 0x00	; 0
		    a[i] = 0x00;
     e42:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_hexNumber_u32==0)
	{
		/* If the number zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
     e44:	1f 5f       	subi	r17, 0xFF	; 255
     e46:	14 17       	cp	r17, r20
     e48:	01 f1       	breq	.+64     	; 0xe8a <LCD_DisplayHexNumber+0x7a>
     e4a:	1a 30       	cpi	r17, 0x0A	; 10
     e4c:	d1 f7       	brne	.-12     	; 0xe42 <LCD_DisplayHexNumber+0x32>
     e4e:	1d c0       	rjmp	.+58     	; 0xe8a <LCD_DisplayHexNumber+0x7a>
     e50:	fe 01       	movw	r30, r28
     e52:	31 96       	adiw	r30, 0x01	; 1
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     e54:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_hexNumber_u32!=0)
     e56:	00 97       	sbiw	r24, 0x00	; 0
     e58:	a1 05       	cpc	r26, r1
     e5a:	b1 05       	cpc	r27, r1
     e5c:	61 f0       	breq	.+24     	; 0xe76 <LCD_DisplayHexNumber+0x66>
			{
				/* Extract the digits from the number till it becomes zero.
			   First get the lower nibble and shift the number 4 times.
			   if var_num_u32 = 0xABC then extracted digit will be 0x0C and number will become 0xAB.
			   The process continues till it becomes zero or max digits reached*/
				a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
     e5e:	28 2f       	mov	r18, r24
     e60:	2f 70       	andi	r18, 0x0F	; 15
     e62:	20 83       	st	Z, r18
				var_hexNumber_u32=var_hexNumber_u32 >> 4;
     e64:	68 94       	set
     e66:	13 f8       	bld	r1, 3
     e68:	b6 95       	lsr	r27
     e6a:	a7 95       	ror	r26
     e6c:	97 95       	ror	r25
     e6e:	87 95       	ror	r24
     e70:	16 94       	lsr	r1
     e72:	d1 f7       	brne	.-12     	; 0xe68 <LCD_DisplayHexNumber+0x58>
     e74:	03 c0       	rjmp	.+6      	; 0xe7c <LCD_DisplayHexNumber+0x6c>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
     e76:	4b 30       	cpi	r20, 0x0B	; 11
     e78:	30 f4       	brcc	.+12     	; 0xe86 <LCD_DisplayHexNumber+0x76>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
				a[i]=0x00;
     e7a:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		    a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     e7c:	1f 5f       	subi	r17, 0xFF	; 255
     e7e:	31 96       	adiw	r30, 0x01	; 1
     e80:	14 17       	cp	r17, r20
     e82:	49 f7       	brne	.-46     	; 0xe56 <LCD_DisplayHexNumber+0x46>
     e84:	02 c0       	rjmp	.+4      	; 0xe8a <LCD_DisplayHexNumber+0x7a>
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
     e86:	11 23       	and	r17, r17
     e88:	61 f0       	breq	.+24     	; 0xea2 <LCD_DisplayHexNumber+0x92>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     e8a:	fe 01       	movw	r30, r28
     e8c:	e1 0f       	add	r30, r17
     e8e:	f1 1d       	adc	r31, r1
     e90:	80 81       	ld	r24, Z
     e92:	8a 30       	cpi	r24, 0x0A	; 10
     e94:	10 f0       	brcs	.+4      	; 0xe9a <LCD_DisplayHexNumber+0x8a>
     e96:	89 5c       	subi	r24, 0xC9	; 201
     e98:	01 c0       	rjmp	.+2      	; 0xe9c <LCD_DisplayHexNumber+0x8c>
     e9a:	80 5d       	subi	r24, 0xD0	; 208
     e9c:	66 df       	rcall	.-308    	; 0xd6a <LCD_DisplayChar>
		i--;
     e9e:	11 50       	subi	r17, 0x01	; 1
				a[i]=0x00;
			}
		}
	}

	while(i!=0)
     ea0:	a1 f7       	brne	.-24     	; 0xe8a <LCD_DisplayHexNumber+0x7a>
	{
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
		i--;
	}
}
     ea2:	2a 96       	adiw	r28, 0x0a	; 10
     ea4:	0f b6       	in	r0, 0x3f	; 63
     ea6:	f8 94       	cli
     ea8:	de bf       	out	0x3e, r29	; 62
     eaa:	0f be       	out	0x3f, r0	; 63
     eac:	cd bf       	out	0x3d, r28	; 61
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	08 95       	ret

00000eb6 <LCD_DisplayDecimalNumber>:
				2.(12345,6) then 6-digits ie. 012345 will be displayed
				3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_LCD_DisplayDecimalNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1))
void LCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
     eb6:	8f 92       	push	r8
     eb8:	9f 92       	push	r9
     eba:	af 92       	push	r10
     ebc:	bf 92       	push	r11
     ebe:	ef 92       	push	r14
     ec0:	ff 92       	push	r15
     ec2:	0f 93       	push	r16
     ec4:	1f 93       	push	r17
     ec6:	cf 93       	push	r28
     ec8:	df 93       	push	r29
     eca:	cd b7       	in	r28, 0x3d	; 61
     ecc:	de b7       	in	r29, 0x3e	; 62
     ece:	2a 97       	sbiw	r28, 0x0a	; 10
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	f8 94       	cli
     ed4:	de bf       	out	0x3e, r29	; 62
     ed6:	0f be       	out	0x3f, r0	; 63
     ed8:	cd bf       	out	0x3d, r28	; 61
     eda:	dc 01       	movw	r26, r24
     edc:	cb 01       	movw	r24, r22
     ede:	04 2f       	mov	r16, r20
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
     ee0:	00 97       	sbiw	r24, 0x00	; 0
     ee2:	a1 05       	cpc	r26, r1
     ee4:	b1 05       	cpc	r27, r1
     ee6:	19 f0       	breq	.+6      	; 0xeee <LCD_DisplayDecimalNumber+0x38>
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     ee8:	44 23       	and	r20, r20
     eea:	71 f4       	brne	.+28     	; 0xf08 <LCD_DisplayDecimalNumber+0x52>
     eec:	41 c0       	rjmp	.+130    	; 0xf70 <LCD_DisplayDecimalNumber+0xba>
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
     eee:	44 23       	and	r20, r20
     ef0:	09 f4       	brne	.+2      	; 0xef4 <LCD_DisplayDecimalNumber+0x3e>
     ef2:	3e c0       	rjmp	.+124    	; 0xf70 <LCD_DisplayDecimalNumber+0xba>
     ef4:	fe 01       	movw	r30, r28
     ef6:	31 96       	adiw	r30, 0x01	; 1
     ef8:	10 e0       	ldi	r17, 0x00	; 0
	    	a[i] = 0x00;
     efa:	11 92       	st	Z+, r1
	uint8_t i=0,a[10];

	if(var_DecNumber_u32==0)
	{
		/* If the number is zero then update the array with the same for displaying */
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
     efc:	1f 5f       	subi	r17, 0xFF	; 255
     efe:	10 17       	cp	r17, r16
     f00:	79 f1       	breq	.+94     	; 0xf60 <LCD_DisplayDecimalNumber+0xaa>
     f02:	1a 30       	cpi	r17, 0x0A	; 10
     f04:	d1 f7       	brne	.-12     	; 0xefa <LCD_DisplayDecimalNumber+0x44>
     f06:	2c c0       	rjmp	.+88     	; 0xf60 <LCD_DisplayDecimalNumber+0xaa>
     f08:	7e 01       	movw	r14, r28
     f0a:	08 94       	sec
     f0c:	e1 1c       	adc	r14, r1
     f0e:	f1 1c       	adc	r15, r1
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     f10:	10 e0       	ldi	r17, 0x00	; 0
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
     f12:	0f 2e       	mov	r0, r31
     f14:	fa e0       	ldi	r31, 0x0A	; 10
     f16:	8f 2e       	mov	r8, r31
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	9f 2e       	mov	r9, r31
     f1c:	f0 e0       	ldi	r31, 0x00	; 0
     f1e:	af 2e       	mov	r10, r31
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	bf 2e       	mov	r11, r31
     f24:	f0 2d       	mov	r31, r0
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
		{
			/* Continue extracting the digits from right side
			   till the Specified var_numOfDigitsToDisplay_u8 */
			if(var_DecNumber_u32!=0)
     f26:	00 97       	sbiw	r24, 0x00	; 0
     f28:	a1 05       	cpc	r26, r1
     f2a:	b1 05       	cpc	r27, r1
     f2c:	61 f0       	breq	.+24     	; 0xf46 <LCD_DisplayDecimalNumber+0x90>
			{
				/* Extract the digits from the number till it becomes zero.
			    First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
				The process continues till it becomes zero or max digits reached*/
				a[i]=util_GetMod32(var_DecNumber_u32,10);
     f2e:	bc 01       	movw	r22, r24
     f30:	cd 01       	movw	r24, r26
     f32:	a5 01       	movw	r20, r10
     f34:	94 01       	movw	r18, r8
     f36:	d8 d2       	rcall	.+1456   	; 0x14e8 <__udivmodsi4>
     f38:	f7 01       	movw	r30, r14
     f3a:	60 83       	st	Z, r22
				var_DecNumber_u32=var_DecNumber_u32/10;
     f3c:	82 2f       	mov	r24, r18
     f3e:	93 2f       	mov	r25, r19
     f40:	a4 2f       	mov	r26, r20
     f42:	b5 2f       	mov	r27, r21
     f44:	04 c0       	rjmp	.+8      	; 0xf4e <LCD_DisplayDecimalNumber+0x98>
			}
			else if( (var_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
     f46:	0b 30       	cpi	r16, 0x0B	; 11
     f48:	48 f4       	brcc	.+18     	; 0xf5c <LCD_DisplayDecimalNumber+0xa6>
			else
			{
				/* In case user expects more digits to be displayed than the actual digits in number,
  			    then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i]=0;
     f4a:	f7 01       	movw	r30, r14
     f4c:	10 82       	st	Z, r1
		for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
	    	a[i] = 0x00;
	}
	else
	{
		for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     f4e:	1f 5f       	subi	r17, 0xFF	; 255
     f50:	08 94       	sec
     f52:	e1 1c       	adc	r14, r1
     f54:	f1 1c       	adc	r15, r1
     f56:	10 17       	cp	r17, r16
     f58:	31 f7       	brne	.-52     	; 0xf26 <LCD_DisplayDecimalNumber+0x70>
     f5a:	02 c0       	rjmp	.+4      	; 0xf60 <LCD_DisplayDecimalNumber+0xaa>
			}
		}
	}


	while(i)
     f5c:	11 23       	and	r17, r17
     f5e:	41 f0       	breq	.+16     	; 0xf70 <LCD_DisplayDecimalNumber+0xba>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
     f60:	fe 01       	movw	r30, r28
     f62:	e1 0f       	add	r30, r17
     f64:	f1 1d       	adc	r31, r1
     f66:	80 81       	ld	r24, Z
     f68:	80 5d       	subi	r24, 0xD0	; 208
     f6a:	ff de       	rcall	.-514    	; 0xd6a <LCD_DisplayChar>
		i--;
     f6c:	11 50       	subi	r17, 0x01	; 1
			}
		}
	}


	while(i)
     f6e:	c1 f7       	brne	.-16     	; 0xf60 <LCD_DisplayDecimalNumber+0xaa>
	{ 
		/* Finally get the ascii values of the digits and display*/
		LCD_DisplayChar(util_Dec2Ascii(a[i-1]));
		i--;
	}
}
     f70:	2a 96       	adiw	r28, 0x0a	; 10
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	f8 94       	cli
     f76:	de bf       	out	0x3e, r29	; 62
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	cd bf       	out	0x3d, r28	; 61
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	ff 90       	pop	r15
     f86:	ef 90       	pop	r14
     f88:	bf 90       	pop	r11
     f8a:	af 90       	pop	r10
     f8c:	9f 90       	pop	r9
     f8e:	8f 90       	pop	r8
     f90:	08 95       	ret

00000f92 <LCD_ScrollMessage>:
                 If the specified line number is out of range then the message
				 will be scrolled on first line
 ***************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t var_lineNumber_u8, char *ptr_msgPointer_u8)
{
     f92:	af 92       	push	r10
     f94:	bf 92       	push	r11
     f96:	cf 92       	push	r12
     f98:	df 92       	push	r13
     f9a:	ef 92       	push	r14
     f9c:	ff 92       	push	r15
     f9e:	0f 93       	push	r16
     fa0:	1f 93       	push	r17
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
     fa6:	b8 2e       	mov	r11, r24
     fa8:	6b 01       	movw	r12, r22
	unsigned char i,j;


	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
     faa:	80 91 91 01 	lds	r24, 0x0191
     fae:	8b 15       	cp	r24, r11
     fb0:	10 f4       	brcc	.+4      	; 0xfb6 <LCD_ScrollMessage+0x24>
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range
     fb2:	bb 24       	eor	r11, r11
     fb4:	b3 94       	inc	r11

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor
     fb6:	8c e0       	ldi	r24, 0x0C	; 12
     fb8:	1b de       	rcall	.-970    	; 0xbf0 <LCD_CmdWrite>

	for(i=0;ptr_msgPointer_u8[i];i++)
     fba:	d6 01       	movw	r26, r12
     fbc:	8c 91       	ld	r24, X
     fbe:	88 23       	and	r24, r24
     fc0:	b9 f1       	breq	.+110    	; 0x1030 <LCD_ScrollMessage+0x9e>
     fc2:	d0 e0       	ldi	r29, 0x00	; 0
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
     fc4:	02 e9       	ldi	r16, 0x92	; 146
     fc6:	11 e0       	ldi	r17, 0x01	; 1
     fc8:	aa 24       	eor	r10, r10
	{      
		/* Loop to display the complete string,	each time 16 chars are displayed and
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line
     fca:	8b 2d       	mov	r24, r11
     fcc:	52 de       	rcall	.-860    	; 0xc72 <LCD_GoToLine>

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
     fce:	f8 01       	movw	r30, r16
     fd0:	80 81       	ld	r24, Z
     fd2:	88 23       	and	r24, r24
     fd4:	e9 f0       	breq	.+58     	; 0x1010 <LCD_ScrollMessage+0x7e>
     fd6:	ed 2e       	mov	r14, r29
     fd8:	ff 24       	eor	r15, r15
     fda:	f6 01       	movw	r30, r12
     fdc:	ee 0d       	add	r30, r14
     fde:	ff 1d       	adc	r31, r15
     fe0:	80 81       	ld	r24, Z
     fe2:	88 23       	and	r24, r24
     fe4:	91 f1       	breq	.+100    	; 0x104a <LCD_ScrollMessage+0xb8>
     fe6:	ca 2d       	mov	r28, r10
     fe8:	7f 01       	movw	r14, r30
		{
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
     fea:	bf de       	rcall	.-642    	; 0xd6a <LCD_DisplayChar>
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
     fec:	cf 5f       	subi	r28, 0xFF	; 255
     fee:	d8 01       	movw	r26, r16
     ff0:	8c 91       	ld	r24, X
     ff2:	c8 17       	cp	r28, r24
     ff4:	68 f4       	brcc	.+26     	; 0x1010 <LCD_ScrollMessage+0x7e>
     ff6:	f7 01       	movw	r30, r14
     ff8:	ec 0f       	add	r30, r28
     ffa:	f1 1d       	adc	r31, r1
     ffc:	80 81       	ld	r24, Z
     ffe:	88 23       	and	r24, r24
    1000:	a1 f7       	brne	.-24     	; 0xfea <LCD_ScrollMessage+0x58>

		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
		{
			/*If the chars to be scrolled are less than MaxLcdChars,
			  then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
    1002:	80 e2       	ldi	r24, 0x20	; 32
    1004:	b2 de       	rcall	.-668    	; 0xd6a <LCD_DisplayChar>
			j++;
    1006:	cf 5f       	subi	r28, 0xFF	; 255
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i+j]);
		}


		while( j<STK_LCDConfig.mvar_MaxSupportedChars_U8)
    1008:	f8 01       	movw	r30, r16
    100a:	80 81       	ld	r24, Z
    100c:	c8 17       	cp	r28, r24
    100e:	c8 f3       	brcs	.-14     	; 0x1002 <LCD_ScrollMessage+0x70>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1010:	8f e3       	ldi	r24, 0x3F	; 63
    1012:	9d e0       	ldi	r25, 0x0D	; 13
    1014:	a3 e0       	ldi	r26, 0x03	; 3
    1016:	81 50       	subi	r24, 0x01	; 1
    1018:	90 40       	sbci	r25, 0x00	; 0
    101a:	a0 40       	sbci	r26, 0x00	; 0
    101c:	e1 f7       	brne	.-8      	; 0x1016 <LCD_ScrollMessage+0x84>
    101e:	00 c0       	rjmp	.+0      	; 0x1020 <LCD_ScrollMessage+0x8e>
    1020:	00 00       	nop
	if(var_lineNumber_u8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
		var_lineNumber_u8 = mENUM_LcdLineOne; // Select first line if the var_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);			 //Disable the Cursor

	for(i=0;ptr_msgPointer_u8[i];i++)
    1022:	df 5f       	subi	r29, 0xFF	; 255
    1024:	f6 01       	movw	r30, r12
    1026:	ed 0f       	add	r30, r29
    1028:	f1 1d       	adc	r31, r1
    102a:	80 81       	ld	r24, Z
    102c:	88 23       	and	r24, r24
    102e:	69 f6       	brne	.-102    	; 0xfca <LCD_ScrollMessage+0x38>
			j++;
		}

		DELAY_ms(125);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);			  // Finally enable the Cursor
    1030:	8e e0       	ldi	r24, 0x0E	; 14
    1032:	de dd       	rcall	.-1092   	; 0xbf0 <LCD_CmdWrite>
}
    1034:	df 91       	pop	r29
    1036:	cf 91       	pop	r28
    1038:	1f 91       	pop	r17
    103a:	0f 91       	pop	r16
    103c:	ff 90       	pop	r15
    103e:	ef 90       	pop	r14
    1040:	df 90       	pop	r13
    1042:	cf 90       	pop	r12
    1044:	bf 90       	pop	r11
    1046:	af 90       	pop	r10
    1048:	08 95       	ret
		pointer is incremented to point to next char */


		LCD_GoToLine(var_lineNumber_u8);     //Move the Cursor to first line

		for(j=0;j<STK_LCDConfig.mvar_MaxSupportedChars_U8 && ptr_msgPointer_u8[i+j];j++)
    104a:	ca 2d       	mov	r28, r10
    104c:	da cf       	rjmp	.-76     	; 0x1002 <LCD_ScrollMessage+0x70>

0000104e <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
    104e:	cf 93       	push	r28
    1050:	df 93       	push	r29
    1052:	ec 01       	movw	r28, r24
	while((*ptr_stringPointer_u8)!=0)
    1054:	88 81       	ld	r24, Y
    1056:	88 23       	and	r24, r24
    1058:	29 f0       	breq	.+10     	; 0x1064 <LCD_DisplayString+0x16>
                 1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
    105a:	21 96       	adiw	r28, 0x01	; 1
{
	while((*ptr_stringPointer_u8)!=0)
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
    105c:	86 de       	rcall	.-756    	; 0xd6a <LCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(char *ptr_stringPointer_u8)
{
	while((*ptr_stringPointer_u8)!=0)
    105e:	89 91       	ld	r24, Y+
    1060:	88 23       	and	r24, r24
    1062:	e1 f7       	brne	.-8      	; 0x105c <LCD_DisplayString+0xe>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
    1064:	df 91       	pop	r29
    1066:	cf 91       	pop	r28
    1068:	08 95       	ret

0000106a <LCD_Printf>:
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
    106a:	5f 92       	push	r5
    106c:	6f 92       	push	r6
    106e:	7f 92       	push	r7
    1070:	8f 92       	push	r8
    1072:	9f 92       	push	r9
    1074:	af 92       	push	r10
    1076:	bf 92       	push	r11
    1078:	cf 92       	push	r12
    107a:	df 92       	push	r13
    107c:	ef 92       	push	r14
    107e:	ff 92       	push	r15
    1080:	0f 93       	push	r16
    1082:	1f 93       	push	r17
    1084:	cf 93       	push	r28
    1086:	df 93       	push	r29
    1088:	cd b7       	in	r28, 0x3d	; 61
    108a:	de b7       	in	r29, 0x3e	; 62
    108c:	0f 2e       	mov	r0, r31
    108e:	f2 e1       	ldi	r31, 0x12	; 18
    1090:	cf 2e       	mov	r12, r31
    1092:	dd 24       	eor	r13, r13
    1094:	f0 2d       	mov	r31, r0
    1096:	cc 0e       	add	r12, r28
    1098:	dd 1e       	adc	r13, r29
    109a:	d6 01       	movw	r26, r12
    109c:	ed 91       	ld	r30, X+
    109e:	fd 91       	ld	r31, X+
    10a0:	6d 01       	movw	r12, r26
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    10a2:	80 81       	ld	r24, Z
    10a4:	88 23       	and	r24, r24
    10a6:	09 f4       	brne	.+2      	; 0x10aa <LCD_Printf+0x40>
    10a8:	f1 c0       	rjmp	.+482    	; 0x128c <LCD_Printf+0x222>
    10aa:	8f 01       	movw	r16, r30

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
    10ac:	55 24       	eor	r5, r5
    10ae:	68 94       	set
    10b0:	54 f8       	bld	r5, 4
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    10b2:	99 24       	eor	r9, r9
    10b4:	9a 94       	dec	r9
	 ex: %4d: will display the lower four digits of the decimal number.
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
    10b6:	88 24       	eor	r8, r8
	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
	{

		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    10b8:	85 32       	cpi	r24, 0x25	; 37
    10ba:	09 f0       	breq	.+2      	; 0x10be <LCD_Printf+0x54>
    10bc:	db c0       	rjmp	.+438    	; 0x1274 <LCD_Printf+0x20a>
		{
		    ptr++;
    10be:	58 01       	movw	r10, r16
    10c0:	08 94       	sec
    10c2:	a1 1c       	adc	r10, r1
    10c4:	b1 1c       	adc	r11, r1
		    ch = *ptr;
    10c6:	f8 01       	movw	r30, r16
    10c8:	81 81       	ldd	r24, Z+1	; 0x01
		   if((ch>=0x30) && (ch<=0x39))
    10ca:	98 2f       	mov	r25, r24
    10cc:	90 53       	subi	r25, 0x30	; 48
    10ce:	9a 30       	cpi	r25, 0x0A	; 10
    10d0:	80 f4       	brcc	.+32     	; 0x10f2 <LCD_Printf+0x88>
	 ex: %4d: will display the lower four digits of the decimal number.
	     %12b: will display the 12-LSB of the number
		 %d: Will display the exact digits of the number
 *************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
    10d2:	32 96       	adiw	r30, 0x02	; 2
    10d4:	18 2d       	mov	r17, r8
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
			    {
				   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
    10d6:	11 0f       	add	r17, r17
    10d8:	91 2f       	mov	r25, r17
    10da:	99 0f       	add	r25, r25
    10dc:	99 0f       	add	r25, r25
    10de:	19 0f       	add	r17, r25
    10e0:	80 53       	subi	r24, 0x30	; 48
    10e2:	18 0f       	add	r17, r24
				   ptr++;
    10e4:	5f 01       	movw	r10, r30
				   ch = *ptr;
    10e6:	81 91       	ld	r24, Z+
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   var_numOfDigitsToDisp_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
    10e8:	98 2f       	mov	r25, r24
    10ea:	90 53       	subi	r25, 0x30	; 48
    10ec:	9a 30       	cpi	r25, 0x0A	; 10
    10ee:	98 f3       	brcs	.-26     	; 0x10d6 <LCD_Printf+0x6c>
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <LCD_Printf+0x8a>
				   ch = *ptr;
				}
			}
			else
			{
			  var_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    10f2:	19 2d       	mov	r17, r9
			}				


			switch(ch)       /* Decode the type of the argument */
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	85 97       	sbiw	r24, 0x25	; 37
    10f8:	84 35       	cpi	r24, 0x54	; 84
    10fa:	91 05       	cpc	r25, r1
    10fc:	08 f0       	brcs	.+2      	; 0x1100 <LCD_Printf+0x96>
    10fe:	bc c0       	rjmp	.+376    	; 0x1278 <LCD_Printf+0x20e>
    1100:	83 5e       	subi	r24, 0xE3	; 227
    1102:	9f 4f       	sbci	r25, 0xFF	; 255
    1104:	8f 93       	push	r24
    1106:	9f 93       	push	r25
    1108:	08 95       	ret
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
    110a:	86 01       	movw	r16, r12
    110c:	0e 5f       	subi	r16, 0xFE	; 254
    110e:	1f 4f       	sbci	r17, 0xFF	; 255
				LCD_DisplayChar(ch);
    1110:	d6 01       	movw	r26, r12
    1112:	8c 91       	ld	r24, X
    1114:	2a de       	rcall	.-940    	; 0xd6a <LCD_DisplayChar>

			switch(ch)       /* Decode the type of the argument */
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, uint16_t);
    1116:	68 01       	movw	r12, r16
				LCD_DisplayChar(ch);
				break;
    1118:	af c0       	rjmp	.+350    	; 0x1278 <LCD_Printf+0x20e>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
    111a:	ee 24       	eor	r14, r14
    111c:	ff 24       	eor	r15, r15
    111e:	68 94       	set
    1120:	e1 f8       	bld	r14, 1
    1122:	ec 0c       	add	r14, r12
    1124:	fd 1c       	adc	r15, r13
    1126:	f6 01       	movw	r30, r12
    1128:	c0 80       	ld	r12, Z
    112a:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_LCD_DisplayDecimalNumber == 1)
				if(var_num_s16<0)
    112c:	dd 20       	and	r13, r13
    112e:	34 f4       	brge	.+12     	; 0x113c <LCD_Printf+0xd2>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   var_num_s16 = -var_num_s16;
    1130:	d0 94       	com	r13
    1132:	c1 94       	neg	r12
    1134:	d1 08       	sbc	r13, r1
    1136:	d3 94       	inc	r13
				   LCD_DisplayChar('-');
    1138:	8d e2       	ldi	r24, 0x2D	; 45
    113a:	17 de       	rcall	.-978    	; 0xd6a <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
    113c:	b6 01       	movw	r22, r12
    113e:	88 27       	eor	r24, r24
    1140:	77 fd       	sbrc	r23, 7
    1142:	80 95       	com	r24
    1144:	98 2f       	mov	r25, r24
    1146:	41 2f       	mov	r20, r17
    1148:	b6 de       	rcall	.-660    	; 0xeb6 <LCD_DisplayDecimalNumber>
				ch = va_arg(argp, uint16_t);
				LCD_DisplayChar(ch);
				break;

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				var_num_s16 = va_arg(argp, sint16_t);
    114a:	67 01       	movw	r12, r14
				   var_num_s16 = -var_num_s16;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
    114c:	95 c0       	rjmp	.+298    	; 0x1278 <LCD_Printf+0x20e>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
    114e:	66 24       	eor	r6, r6
    1150:	77 24       	eor	r7, r7
    1152:	68 94       	set
    1154:	62 f8       	bld	r6, 2
    1156:	6c 0c       	add	r6, r12
    1158:	7d 1c       	adc	r7, r13
    115a:	d6 01       	movw	r26, r12
    115c:	cd 90       	ld	r12, X+
    115e:	dd 90       	ld	r13, X+
    1160:	ed 90       	ld	r14, X+
    1162:	fc 90       	ld	r15, X
    1164:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				if(var_num_s32<0)
    1166:	ff 20       	and	r15, r15
    1168:	54 f4       	brge	.+20     	; 0x117e <LCD_Printf+0x114>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   var_num_s32 = -var_num_s32;
    116a:	f0 94       	com	r15
    116c:	e0 94       	com	r14
    116e:	d0 94       	com	r13
    1170:	c0 94       	com	r12
    1172:	c1 1c       	adc	r12, r1
    1174:	d1 1c       	adc	r13, r1
    1176:	e1 1c       	adc	r14, r1
    1178:	f1 1c       	adc	r15, r1
				   LCD_DisplayChar('-');
    117a:	8d e2       	ldi	r24, 0x2D	; 45
    117c:	f6 dd       	rcall	.-1044   	; 0xd6a <LCD_DisplayChar>
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
    117e:	c7 01       	movw	r24, r14
    1180:	b6 01       	movw	r22, r12
    1182:	41 2f       	mov	r20, r17
    1184:	98 de       	rcall	.-720    	; 0xeb6 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
				break;
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				var_num_s32 = va_arg(argp, sint32_t);
    1186:	63 01       	movw	r12, r6
				   var_num_s32 = -var_num_s32;
				   LCD_DisplayChar('-');
				 }
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	
    1188:	77 c0       	rjmp	.+238    	; 0x1278 <LCD_Printf+0x20e>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
    118a:	ee 24       	eor	r14, r14
    118c:	ff 24       	eor	r15, r15
    118e:	68 94       	set
    1190:	e1 f8       	bld	r14, 1
    1192:	ec 0c       	add	r14, r12
    1194:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
    1196:	f6 01       	movw	r30, r12
    1198:	80 81       	ld	r24, Z
    119a:	91 81       	ldd	r25, Z+1	; 0x01
    119c:	bc 01       	movw	r22, r24
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	41 2f       	mov	r20, r17
    11a4:	88 de       	rcall	.-752    	; 0xeb6 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif				
				break;	

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				var_num_u16 = va_arg(argp, uint16_t);
    11a6:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
    11a8:	67 c0       	rjmp	.+206    	; 0x1278 <LCD_Printf+0x20e>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
    11aa:	ee 24       	eor	r14, r14
    11ac:	ff 24       	eor	r15, r15
    11ae:	68 94       	set
    11b0:	e2 f8       	bld	r14, 2
    11b2:	ec 0c       	add	r14, r12
    11b4:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
    11b6:	d6 01       	movw	r26, r12
    11b8:	6d 91       	ld	r22, X+
    11ba:	7d 91       	ld	r23, X+
    11bc:	8d 91       	ld	r24, X+
    11be:	9c 91       	ld	r25, X
    11c0:	41 2f       	mov	r20, r17
    11c2:	79 de       	rcall	.-782    	; 0xeb6 <LCD_DisplayDecimalNumber>
				LCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				var_num_u32 = va_arg(argp, uint32_t);
    11c4:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayDecimalNumber == 1)				
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			
    11c6:	58 c0       	rjmp	.+176    	; 0x1278 <LCD_Printf+0x20e>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
    11c8:	ee 24       	eor	r14, r14
    11ca:	ff 24       	eor	r15, r15
    11cc:	68 94       	set
    11ce:	e1 f8       	bld	r14, 1
    11d0:	ec 0c       	add	r14, r12
    11d2:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
    11d4:	f6 01       	movw	r30, r12
    11d6:	80 81       	ld	r24, Z
    11d8:	91 81       	ldd	r25, Z+1	; 0x01
    11da:	bc 01       	movw	r22, r24
    11dc:	80 e0       	ldi	r24, 0x00	; 0
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	41 2f       	mov	r20, r17
    11e2:	16 de       	rcall	.-980    	; 0xe10 <LCD_DisplayHexNumber>
				LCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;			

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u16 = va_arg(argp, uint16_t);
    11e4:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)				
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
    11e6:	48 c0       	rjmp	.+144    	; 0x1278 <LCD_Printf+0x20e>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
    11e8:	ee 24       	eor	r14, r14
    11ea:	ff 24       	eor	r15, r15
    11ec:	68 94       	set
    11ee:	e2 f8       	bld	r14, 2
    11f0:	ec 0c       	add	r14, r12
    11f2:	fd 1c       	adc	r15, r13
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
    11f4:	d6 01       	movw	r26, r12
    11f6:	6d 91       	ld	r22, X+
    11f8:	7d 91       	ld	r23, X+
    11fa:	8d 91       	ld	r24, X+
    11fc:	9c 91       	ld	r25, X
    11fe:	41 2f       	mov	r20, r17
    1200:	07 de       	rcall	.-1010   	; 0xe10 <LCD_DisplayHexNumber>
				LCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				var_num_u32 = va_arg(argp, uint32_t);
    1202:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayHexNumber == 1)						
				LCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif				
				break;
    1204:	39 c0       	rjmp	.+114    	; 0x1278 <LCD_Printf+0x20e>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
    1206:	ee 24       	eor	r14, r14
    1208:	ff 24       	eor	r15, r15
    120a:	68 94       	set
    120c:	e1 f8       	bld	r14, 1
    120e:	ec 0c       	add	r14, r12
    1210:	fd 1c       	adc	r15, r13
    1212:	f6 01       	movw	r30, r12
    1214:	80 81       	ld	r24, Z
    1216:	91 81       	ldd	r25, Z+1	; 0x01
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    1218:	1f 3f       	cpi	r17, 0xFF	; 255
    121a:	09 f4       	brne	.+2      	; 0x121e <LCD_Printf+0x1b4>
				   var_numOfDigitsToDisp_u8 = 16;
    121c:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
    121e:	bc 01       	movw	r22, r24
    1220:	80 e0       	ldi	r24, 0x00	; 0
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	41 2f       	mov	r20, r17
    1226:	ba dd       	rcall	.-1164   	; 0xd9c <LCD_DisplayBinaryNumber>
#endif				
				break;

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u16 = va_arg(argp, uint16_t);
    1228:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)						
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;
    122a:	26 c0       	rjmp	.+76     	; 0x1278 <LCD_Printf+0x20e>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
    122c:	ee 24       	eor	r14, r14
    122e:	ff 24       	eor	r15, r15
    1230:	68 94       	set
    1232:	e2 f8       	bld	r14, 2
    1234:	ec 0c       	add	r14, r12
    1236:	fd 1c       	adc	r15, r13
    1238:	d6 01       	movw	r26, r12
    123a:	6d 91       	ld	r22, X+
    123c:	7d 91       	ld	r23, X+
    123e:	8d 91       	ld	r24, X+
    1240:	9c 91       	ld	r25, X
    1242:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    1244:	1f 3f       	cpi	r17, 0xFF	; 255
    1246:	09 f4       	brne	.+2      	; 0x124a <LCD_Printf+0x1e0>
				   var_numOfDigitsToDisp_u8 = 16;				
    1248:	15 2d       	mov	r17, r5
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
    124a:	41 2f       	mov	r20, r17
    124c:	a7 dd       	rcall	.-1202   	; 0xd9c <LCD_DisplayBinaryNumber>
				LCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif				
				break;

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				var_num_u32 = va_arg(argp, uint32_t);
    124e:	67 01       	movw	r12, r14
#if (Enable_LCD_DisplayBinaryNumber == 1)				
				if(var_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
				   var_numOfDigitsToDisp_u8 = 16;				
				LCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);	
#endif				
				break;
    1250:	13 c0       	rjmp	.+38     	; 0x1278 <LCD_Printf+0x20e>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
				var_floatNum_f32 = va_arg(argp, double);
    1252:	e4 e0       	ldi	r30, 0x04	; 4
    1254:	f0 e0       	ldi	r31, 0x00	; 0
    1256:	ce 0e       	add	r12, r30
    1258:	df 1e       	adc	r13, r31
#if (Enable_LCD_DisplayFloatNumber == 1)				
				LCD_DisplayFloatNumber(var_floatNum_f32);
#endif
				break;
    125a:	0e c0       	rjmp	.+28     	; 0x1278 <LCD_Printf+0x20e>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
    125c:	f6 01       	movw	r30, r12
    125e:	82 e0       	ldi	r24, 0x02	; 2
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	c8 0e       	add	r12, r24
    1264:	d9 1e       	adc	r13, r25
#if (Enable_LCD_DisplayString == 1)
				LCD_DisplayString(str);
    1266:	80 81       	ld	r24, Z
    1268:	91 81       	ldd	r25, Z+1	; 0x01
    126a:	f1 de       	rcall	.-542    	; 0x104e <LCD_DisplayString>
#endif				
				break;
    126c:	05 c0       	rjmp	.+10     	; 0x1278 <LCD_Printf+0x20e>

			case '%':
				LCD_DisplayChar('%');
    126e:	85 e2       	ldi	r24, 0x25	; 37
    1270:	7c dd       	rcall	.-1288   	; 0xd6a <LCD_DisplayChar>
				break;
    1272:	02 c0       	rjmp	.+4      	; 0x1278 <LCD_Printf+0x20e>
			}
		}
		else
		{
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    1274:	7a dd       	rcall	.-1292   	; 0xd6a <LCD_DisplayChar>
    1276:	58 01       	movw	r10, r16
	uint8_t var_numOfDigitsToDisp_u8;

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    1278:	85 01       	movw	r16, r10
    127a:	0f 5f       	subi	r16, 0xFF	; 255
    127c:	1f 4f       	sbci	r17, 0xFF	; 255
    127e:	d5 01       	movw	r26, r10
    1280:	11 96       	adiw	r26, 0x01	; 1
    1282:	8c 91       	ld	r24, X
    1284:	11 97       	sbiw	r26, 0x01	; 1
    1286:	88 23       	and	r24, r24
    1288:	09 f0       	breq	.+2      	; 0x128c <LCD_Printf+0x222>
    128a:	16 cf       	rjmp	.-468    	; 0x10b8 <LCD_Printf+0x4e>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	1f 91       	pop	r17
    1292:	0f 91       	pop	r16
    1294:	ff 90       	pop	r15
    1296:	ef 90       	pop	r14
    1298:	df 90       	pop	r13
    129a:	cf 90       	pop	r12
    129c:	bf 90       	pop	r11
    129e:	af 90       	pop	r10
    12a0:	9f 90       	pop	r9
    12a2:	8f 90       	pop	r8
    12a4:	7f 90       	pop	r7
    12a6:	6f 90       	pop	r6
    12a8:	5f 90       	pop	r5
    12aa:	08 95       	ret

000012ac <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init()
{
	I2C_Init();                             // Initialize the I2c module.
    12ac:	33 dc       	rcall	.-1946   	; 0xb14 <I2C_Init>
	I2C_Start();                            // Start I2C communication
    12ae:	38 dc       	rcall	.-1936   	; 0xb20 <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
    12b0:	80 ed       	ldi	r24, 0xD0	; 208
    12b2:	43 dc       	rcall	.-1914   	; 0xb3a <I2C_Write>
	I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
    12b4:	87 e0       	ldi	r24, 0x07	; 7
    12b6:	41 dc       	rcall	.-1918   	; 0xb3a <I2C_Write>

	I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
    12b8:	80 e0       	ldi	r24, 0x00	; 0
    12ba:	3f dc       	rcall	.-1922   	; 0xb3a <I2C_Write>

	I2C_Stop();                             // Stop I2C communication after initializing DS1307
    12bc:	37 dc       	rcall	.-1938   	; 0xb2c <I2C_Stop>
}
    12be:	08 95       	ret

000012c0 <RTC_SetTime>:
                 The new time is updated into the non volatile memory of Ds1307.
	Note: The I/P arguments should of BCD, 
	      like 0x12,0x39,0x26 for 12hr,39min and 26sec.			 
***************************************************************************************************/
void RTC_SetTime(uint8_t var_hour_u8, uint8_t var_min_u8, uint8_t var_sec_u8)
{
    12c0:	1f 93       	push	r17
    12c2:	cf 93       	push	r28
    12c4:	df 93       	push	r29
    12c6:	c8 2f       	mov	r28, r24
    12c8:	d6 2f       	mov	r29, r22
    12ca:	14 2f       	mov	r17, r20
	I2C_Start();                            // Start I2C communication
    12cc:	29 dc       	rcall	.-1966   	; 0xb20 <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
    12ce:	80 ed       	ldi	r24, 0xD0	; 208
    12d0:	34 dc       	rcall	.-1944   	; 0xb3a <I2C_Write>
	I2C_Write(C_Ds1307SecondRegAddress_U8); // Select the SEC RAM address
    12d2:	80 e0       	ldi	r24, 0x00	; 0
    12d4:	32 dc       	rcall	.-1948   	; 0xb3a <I2C_Write>

	I2C_Write(var_sec_u8);			        // Write sec from RAM address 00H
    12d6:	81 2f       	mov	r24, r17
    12d8:	30 dc       	rcall	.-1952   	; 0xb3a <I2C_Write>
	I2C_Write(var_min_u8);			        // Write min from RAM address 01H
    12da:	8d 2f       	mov	r24, r29
    12dc:	2e dc       	rcall	.-1956   	; 0xb3a <I2C_Write>
	I2C_Write(var_hour_u8);			        // Write hour from RAM address 02H
    12de:	8c 2f       	mov	r24, r28
    12e0:	2c dc       	rcall	.-1960   	; 0xb3a <I2C_Write>

	I2C_Stop();           	                // Stop I2C communication after Setting the Time
    12e2:	24 dc       	rcall	.-1976   	; 0xb2c <I2C_Stop>
}
    12e4:	df 91       	pop	r29
    12e6:	cf 91       	pop	r28
    12e8:	1f 91       	pop	r17
    12ea:	08 95       	ret

000012ec <RTC_SetDate>:
                 The new Date is updated into the non volatile memory of Ds1307.
		Note: The I/P arguments should of BCD, 
	      like 0x15,0x08,0x47 for 15th day,8th month and 47th year.				 
***************************************************************************************************/
void RTC_SetDate(uint8_t var_day_u8, uint8_t var_month_u8, uint8_t var_year_u8)
{
    12ec:	1f 93       	push	r17
    12ee:	cf 93       	push	r28
    12f0:	df 93       	push	r29
    12f2:	18 2f       	mov	r17, r24
    12f4:	d6 2f       	mov	r29, r22
    12f6:	c4 2f       	mov	r28, r20
	I2C_Start();                          // Start I2C communication
    12f8:	13 dc       	rcall	.-2010   	; 0xb20 <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	  // connect to DS1307 by sending its ID on I2c Bus
    12fa:	80 ed       	ldi	r24, 0xD0	; 208
    12fc:	1e dc       	rcall	.-1988   	; 0xb3a <I2C_Write>
	I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
    12fe:	84 e0       	ldi	r24, 0x04	; 4
    1300:	1c dc       	rcall	.-1992   	; 0xb3a <I2C_Write>

	I2C_Write(var_day_u8);			      // Write date on RAM address 04H
    1302:	81 2f       	mov	r24, r17
    1304:	1a dc       	rcall	.-1996   	; 0xb3a <I2C_Write>
	I2C_Write(var_month_u8);			      // Write month on RAM address 05H
    1306:	8d 2f       	mov	r24, r29
    1308:	18 dc       	rcall	.-2000   	; 0xb3a <I2C_Write>
	I2C_Write(var_year_u8);			      // Write year on RAM address 06h
    130a:	8c 2f       	mov	r24, r28
    130c:	16 dc       	rcall	.-2004   	; 0xb3a <I2C_Write>

	I2C_Stop();				              // Stop I2C communication after Setting the Date
    130e:	0e dc       	rcall	.-2020   	; 0xb2c <I2C_Stop>
}
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	1f 91       	pop	r17
    1316:	08 95       	ret

00001318 <RTC_GetTime>:

	Note: The time read from Ds1307 will be of BCD format, 
	      like 0x12,0x39,0x26 for 12hr,39min and 26sec.	
***************************************************************************************************/
void RTC_GetTime(uint8_t *ptr_hour_u8,uint8_t *ptr_min_u8,uint8_t *ptr_sec_u8)
{
    1318:	ef 92       	push	r14
    131a:	ff 92       	push	r15
    131c:	0f 93       	push	r16
    131e:	1f 93       	push	r17
    1320:	cf 93       	push	r28
    1322:	df 93       	push	r29
    1324:	7c 01       	movw	r14, r24
    1326:	8b 01       	movw	r16, r22
    1328:	ea 01       	movw	r28, r20
	I2C_Start();                            // Start I2C communication
    132a:	fa db       	rcall	.-2060   	; 0xb20 <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	    // connect to DS1307 by sending its ID on I2c Bus
    132c:	80 ed       	ldi	r24, 0xD0	; 208
    132e:	05 dc       	rcall	.-2038   	; 0xb3a <I2C_Write>
	I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
    1330:	80 e0       	ldi	r24, 0x00	; 0
    1332:	03 dc       	rcall	.-2042   	; 0xb3a <I2C_Write>

	I2C_Stop();			                    // Stop I2C communication after selecting Sec Register
    1334:	fb db       	rcall	.-2058   	; 0xb2c <I2C_Stop>

	I2C_Start();		                    // Start I2C communication
    1336:	f4 db       	rcall	.-2072   	; 0xb20 <I2C_Start>
	I2C_Write(C_Ds1307ReadMode_U8);	        // connect to DS1307(Read mode) by sending its ID
    1338:	81 ed       	ldi	r24, 0xD1	; 209
    133a:	ff db       	rcall	.-2050   	; 0xb3a <I2C_Write>

	*ptr_sec_u8 = I2C_Read(1);                // read second and return Positive ACK
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	04 dc       	rcall	.-2040   	; 0xb48 <I2C_Read>
    1340:	88 83       	st	Y, r24
	*ptr_min_u8 = I2C_Read(1); 	            // read minute and return Positive ACK
    1342:	81 e0       	ldi	r24, 0x01	; 1
    1344:	01 dc       	rcall	.-2046   	; 0xb48 <I2C_Read>
    1346:	f8 01       	movw	r30, r16
    1348:	80 83       	st	Z, r24
	*ptr_hour_u8 = I2C_Read(0);               // read hour and return Negative/No ACK
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	fd db       	rcall	.-2054   	; 0xb48 <I2C_Read>
    134e:	f7 01       	movw	r30, r14
    1350:	80 83       	st	Z, r24

	I2C_Stop();		                        // Stop I2C communication after reading the Time
    1352:	ec db       	rcall	.-2088   	; 0xb2c <I2C_Stop>
}
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	1f 91       	pop	r17
    135a:	0f 91       	pop	r16
    135c:	ff 90       	pop	r15
    135e:	ef 90       	pop	r14
    1360:	08 95       	ret

00001362 <RTC_GetDate>:

	Note: The date read from Ds1307 will be of BCD format, 
	      like 0x15,0x08,0x47 for 15th day,8th month and 47th year.			  
***************************************************************************************************/
void RTC_GetDate(uint8_t *ptr_day_u8,uint8_t *ptr_month_u8,uint8_t *ptr_year_u8)
{
    1362:	ef 92       	push	r14
    1364:	ff 92       	push	r15
    1366:	0f 93       	push	r16
    1368:	1f 93       	push	r17
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	ec 01       	movw	r28, r24
    1370:	8b 01       	movw	r16, r22
    1372:	7a 01       	movw	r14, r20
	I2C_Start();                          // Start I2C communication
    1374:	d5 db       	rcall	.-2134   	; 0xb20 <I2C_Start>

	I2C_Write(C_Ds1307WriteMode_U8);	      // connect to DS1307 by sending its ID on I2c Bus
    1376:	80 ed       	ldi	r24, 0xD0	; 208
    1378:	e0 db       	rcall	.-2112   	; 0xb3a <I2C_Write>
	I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
    137a:	84 e0       	ldi	r24, 0x04	; 4
    137c:	de db       	rcall	.-2116   	; 0xb3a <I2C_Write>

	I2C_Stop();			                  // Stop I2C communication after selecting DAY Register
    137e:	d6 db       	rcall	.-2132   	; 0xb2c <I2C_Stop>


	I2C_Start();		                  // Start I2C communication
    1380:	cf db       	rcall	.-2146   	; 0xb20 <I2C_Start>
	I2C_Write(C_Ds1307ReadMode_U8);	      // connect to DS1307(Read mode) by sending its ID
    1382:	81 ed       	ldi	r24, 0xD1	; 209
    1384:	da db       	rcall	.-2124   	; 0xb3a <I2C_Write>

	*ptr_day_u8 = I2C_Read(1);              // read Day and return Positive ACK
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	df db       	rcall	.-2114   	; 0xb48 <I2C_Read>
    138a:	88 83       	st	Y, r24
	*ptr_month_u8 = I2C_Read(1);            // read Month and return Positive ACK
    138c:	81 e0       	ldi	r24, 0x01	; 1
    138e:	dc db       	rcall	.-2120   	; 0xb48 <I2C_Read>
    1390:	f8 01       	movw	r30, r16
    1392:	80 83       	st	Z, r24
	*ptr_year_u8 = I2C_Read(0);             // read Year and return Negative/No ACK
    1394:	80 e0       	ldi	r24, 0x00	; 0
    1396:	d8 db       	rcall	.-2128   	; 0xb48 <I2C_Read>
    1398:	f7 01       	movw	r30, r14
    139a:	80 83       	st	Z, r24

	I2C_Stop();		                      // Stop I2C communication after reading the Date
    139c:	c7 db       	rcall	.-2162   	; 0xb2c <I2C_Stop>
}
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	1f 91       	pop	r17
    13a4:	0f 91       	pop	r16
    13a6:	ff 90       	pop	r15
    13a8:	ef 90       	pop	r14
    13aa:	08 95       	ret

000013ac <__fixunssfsi>:
    13ac:	70 d0       	rcall	.+224    	; 0x148e <__fp_splitA>
    13ae:	88 f0       	brcs	.+34     	; 0x13d2 <__fixunssfsi+0x26>
    13b0:	9f 57       	subi	r25, 0x7F	; 127
    13b2:	90 f0       	brcs	.+36     	; 0x13d8 <__fixunssfsi+0x2c>
    13b4:	b9 2f       	mov	r27, r25
    13b6:	99 27       	eor	r25, r25
    13b8:	b7 51       	subi	r27, 0x17	; 23
    13ba:	a0 f0       	brcs	.+40     	; 0x13e4 <__fixunssfsi+0x38>
    13bc:	d1 f0       	breq	.+52     	; 0x13f2 <__fixunssfsi+0x46>
    13be:	66 0f       	add	r22, r22
    13c0:	77 1f       	adc	r23, r23
    13c2:	88 1f       	adc	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	1a f0       	brmi	.+6      	; 0x13ce <__fixunssfsi+0x22>
    13c8:	ba 95       	dec	r27
    13ca:	c9 f7       	brne	.-14     	; 0x13be <__fixunssfsi+0x12>
    13cc:	12 c0       	rjmp	.+36     	; 0x13f2 <__fixunssfsi+0x46>
    13ce:	b1 30       	cpi	r27, 0x01	; 1
    13d0:	81 f0       	breq	.+32     	; 0x13f2 <__fixunssfsi+0x46>
    13d2:	77 d0       	rcall	.+238    	; 0x14c2 <__fp_zero>
    13d4:	b1 e0       	ldi	r27, 0x01	; 1
    13d6:	08 95       	ret
    13d8:	74 c0       	rjmp	.+232    	; 0x14c2 <__fp_zero>
    13da:	67 2f       	mov	r22, r23
    13dc:	78 2f       	mov	r23, r24
    13de:	88 27       	eor	r24, r24
    13e0:	b8 5f       	subi	r27, 0xF8	; 248
    13e2:	39 f0       	breq	.+14     	; 0x13f2 <__fixunssfsi+0x46>
    13e4:	b9 3f       	cpi	r27, 0xF9	; 249
    13e6:	cc f3       	brlt	.-14     	; 0x13da <__fixunssfsi+0x2e>
    13e8:	86 95       	lsr	r24
    13ea:	77 95       	ror	r23
    13ec:	67 95       	ror	r22
    13ee:	b3 95       	inc	r27
    13f0:	d9 f7       	brne	.-10     	; 0x13e8 <__fixunssfsi+0x3c>
    13f2:	3e f4       	brtc	.+14     	; 0x1402 <__fixunssfsi+0x56>
    13f4:	90 95       	com	r25
    13f6:	80 95       	com	r24
    13f8:	70 95       	com	r23
    13fa:	61 95       	neg	r22
    13fc:	7f 4f       	sbci	r23, 0xFF	; 255
    13fe:	8f 4f       	sbci	r24, 0xFF	; 255
    1400:	9f 4f       	sbci	r25, 0xFF	; 255
    1402:	08 95       	ret

00001404 <__floatunsisf>:
    1404:	e8 94       	clt
    1406:	09 c0       	rjmp	.+18     	; 0x141a <__floatsisf+0x12>

00001408 <__floatsisf>:
    1408:	97 fb       	bst	r25, 7
    140a:	3e f4       	brtc	.+14     	; 0x141a <__floatsisf+0x12>
    140c:	90 95       	com	r25
    140e:	80 95       	com	r24
    1410:	70 95       	com	r23
    1412:	61 95       	neg	r22
    1414:	7f 4f       	sbci	r23, 0xFF	; 255
    1416:	8f 4f       	sbci	r24, 0xFF	; 255
    1418:	9f 4f       	sbci	r25, 0xFF	; 255
    141a:	99 23       	and	r25, r25
    141c:	a9 f0       	breq	.+42     	; 0x1448 <__floatsisf+0x40>
    141e:	f9 2f       	mov	r31, r25
    1420:	96 e9       	ldi	r25, 0x96	; 150
    1422:	bb 27       	eor	r27, r27
    1424:	93 95       	inc	r25
    1426:	f6 95       	lsr	r31
    1428:	87 95       	ror	r24
    142a:	77 95       	ror	r23
    142c:	67 95       	ror	r22
    142e:	b7 95       	ror	r27
    1430:	f1 11       	cpse	r31, r1
    1432:	f8 cf       	rjmp	.-16     	; 0x1424 <__floatsisf+0x1c>
    1434:	fa f4       	brpl	.+62     	; 0x1474 <__floatsisf+0x6c>
    1436:	bb 0f       	add	r27, r27
    1438:	11 f4       	brne	.+4      	; 0x143e <__floatsisf+0x36>
    143a:	60 ff       	sbrs	r22, 0
    143c:	1b c0       	rjmp	.+54     	; 0x1474 <__floatsisf+0x6c>
    143e:	6f 5f       	subi	r22, 0xFF	; 255
    1440:	7f 4f       	sbci	r23, 0xFF	; 255
    1442:	8f 4f       	sbci	r24, 0xFF	; 255
    1444:	9f 4f       	sbci	r25, 0xFF	; 255
    1446:	16 c0       	rjmp	.+44     	; 0x1474 <__floatsisf+0x6c>
    1448:	88 23       	and	r24, r24
    144a:	11 f0       	breq	.+4      	; 0x1450 <__floatsisf+0x48>
    144c:	96 e9       	ldi	r25, 0x96	; 150
    144e:	11 c0       	rjmp	.+34     	; 0x1472 <__floatsisf+0x6a>
    1450:	77 23       	and	r23, r23
    1452:	21 f0       	breq	.+8      	; 0x145c <__floatsisf+0x54>
    1454:	9e e8       	ldi	r25, 0x8E	; 142
    1456:	87 2f       	mov	r24, r23
    1458:	76 2f       	mov	r23, r22
    145a:	05 c0       	rjmp	.+10     	; 0x1466 <__floatsisf+0x5e>
    145c:	66 23       	and	r22, r22
    145e:	71 f0       	breq	.+28     	; 0x147c <__floatsisf+0x74>
    1460:	96 e8       	ldi	r25, 0x86	; 134
    1462:	86 2f       	mov	r24, r22
    1464:	70 e0       	ldi	r23, 0x00	; 0
    1466:	60 e0       	ldi	r22, 0x00	; 0
    1468:	2a f0       	brmi	.+10     	; 0x1474 <__floatsisf+0x6c>
    146a:	9a 95       	dec	r25
    146c:	66 0f       	add	r22, r22
    146e:	77 1f       	adc	r23, r23
    1470:	88 1f       	adc	r24, r24
    1472:	da f7       	brpl	.-10     	; 0x146a <__floatsisf+0x62>
    1474:	88 0f       	add	r24, r24
    1476:	96 95       	lsr	r25
    1478:	87 95       	ror	r24
    147a:	97 f9       	bld	r25, 7
    147c:	08 95       	ret

0000147e <__fp_split3>:
    147e:	57 fd       	sbrc	r21, 7
    1480:	90 58       	subi	r25, 0x80	; 128
    1482:	44 0f       	add	r20, r20
    1484:	55 1f       	adc	r21, r21
    1486:	59 f0       	breq	.+22     	; 0x149e <__fp_splitA+0x10>
    1488:	5f 3f       	cpi	r21, 0xFF	; 255
    148a:	71 f0       	breq	.+28     	; 0x14a8 <__fp_splitA+0x1a>
    148c:	47 95       	ror	r20

0000148e <__fp_splitA>:
    148e:	88 0f       	add	r24, r24
    1490:	97 fb       	bst	r25, 7
    1492:	99 1f       	adc	r25, r25
    1494:	61 f0       	breq	.+24     	; 0x14ae <__fp_splitA+0x20>
    1496:	9f 3f       	cpi	r25, 0xFF	; 255
    1498:	79 f0       	breq	.+30     	; 0x14b8 <__fp_splitA+0x2a>
    149a:	87 95       	ror	r24
    149c:	08 95       	ret
    149e:	12 16       	cp	r1, r18
    14a0:	13 06       	cpc	r1, r19
    14a2:	14 06       	cpc	r1, r20
    14a4:	55 1f       	adc	r21, r21
    14a6:	f2 cf       	rjmp	.-28     	; 0x148c <__fp_split3+0xe>
    14a8:	46 95       	lsr	r20
    14aa:	f1 df       	rcall	.-30     	; 0x148e <__fp_splitA>
    14ac:	08 c0       	rjmp	.+16     	; 0x14be <__fp_splitA+0x30>
    14ae:	16 16       	cp	r1, r22
    14b0:	17 06       	cpc	r1, r23
    14b2:	18 06       	cpc	r1, r24
    14b4:	99 1f       	adc	r25, r25
    14b6:	f1 cf       	rjmp	.-30     	; 0x149a <__fp_splitA+0xc>
    14b8:	86 95       	lsr	r24
    14ba:	71 05       	cpc	r23, r1
    14bc:	61 05       	cpc	r22, r1
    14be:	08 94       	sec
    14c0:	08 95       	ret

000014c2 <__fp_zero>:
    14c2:	e8 94       	clt

000014c4 <__fp_szero>:
    14c4:	bb 27       	eor	r27, r27
    14c6:	66 27       	eor	r22, r22
    14c8:	77 27       	eor	r23, r23
    14ca:	cb 01       	movw	r24, r22
    14cc:	97 f9       	bld	r25, 7
    14ce:	08 95       	ret

000014d0 <__udivmodqi4>:
    14d0:	99 1b       	sub	r25, r25
    14d2:	79 e0       	ldi	r23, 0x09	; 9
    14d4:	04 c0       	rjmp	.+8      	; 0x14de <__udivmodqi4_ep>

000014d6 <__udivmodqi4_loop>:
    14d6:	99 1f       	adc	r25, r25
    14d8:	96 17       	cp	r25, r22
    14da:	08 f0       	brcs	.+2      	; 0x14de <__udivmodqi4_ep>
    14dc:	96 1b       	sub	r25, r22

000014de <__udivmodqi4_ep>:
    14de:	88 1f       	adc	r24, r24
    14e0:	7a 95       	dec	r23
    14e2:	c9 f7       	brne	.-14     	; 0x14d6 <__udivmodqi4_loop>
    14e4:	80 95       	com	r24
    14e6:	08 95       	ret

000014e8 <__udivmodsi4>:
    14e8:	a1 e2       	ldi	r26, 0x21	; 33
    14ea:	1a 2e       	mov	r1, r26
    14ec:	aa 1b       	sub	r26, r26
    14ee:	bb 1b       	sub	r27, r27
    14f0:	fd 01       	movw	r30, r26
    14f2:	0d c0       	rjmp	.+26     	; 0x150e <__udivmodsi4_ep>

000014f4 <__udivmodsi4_loop>:
    14f4:	aa 1f       	adc	r26, r26
    14f6:	bb 1f       	adc	r27, r27
    14f8:	ee 1f       	adc	r30, r30
    14fa:	ff 1f       	adc	r31, r31
    14fc:	a2 17       	cp	r26, r18
    14fe:	b3 07       	cpc	r27, r19
    1500:	e4 07       	cpc	r30, r20
    1502:	f5 07       	cpc	r31, r21
    1504:	20 f0       	brcs	.+8      	; 0x150e <__udivmodsi4_ep>
    1506:	a2 1b       	sub	r26, r18
    1508:	b3 0b       	sbc	r27, r19
    150a:	e4 0b       	sbc	r30, r20
    150c:	f5 0b       	sbc	r31, r21

0000150e <__udivmodsi4_ep>:
    150e:	66 1f       	adc	r22, r22
    1510:	77 1f       	adc	r23, r23
    1512:	88 1f       	adc	r24, r24
    1514:	99 1f       	adc	r25, r25
    1516:	1a 94       	dec	r1
    1518:	69 f7       	brne	.-38     	; 0x14f4 <__udivmodsi4_loop>
    151a:	60 95       	com	r22
    151c:	70 95       	com	r23
    151e:	80 95       	com	r24
    1520:	90 95       	com	r25
    1522:	9b 01       	movw	r18, r22
    1524:	ac 01       	movw	r20, r24
    1526:	bd 01       	movw	r22, r26
    1528:	cf 01       	movw	r24, r30
    152a:	08 95       	ret

0000152c <_exit>:
    152c:	f8 94       	cli

0000152e <__stop_program>:
    152e:	ff cf       	rjmp	.-2      	; 0x152e <__stop_program>
